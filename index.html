<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">

  <!--
   デフォルトのスタイル
   より見やすく変更しても良い
  -->
  <link rel="stylesheet" href="default.css"/>

  <!--
    SyntaxHighlighter 3.0.83 (http://alexgorbatchev.com/SyntaxHighlighter/)
    Java のコードを読みやすくする
  -->
  <link rel="stylesheet" href="shCore.css"/>
  <link rel="stylesheet" href="shThemeDjango.css"/>
  <script src="shCore.js"></script>
  <script src="shBrushJava.js"></script>
  <script>SyntaxHighlighter.all();</script>

  <!--
    目次を動的に生成する
  -->
  <script src="outliner.js"></script>
  <script>
    window.addEventListener('load', function() {
      // 第一引数: アウトライン対象の要素のセレクタ，第二引数: アウトラインを格納する要素のセレクタ．
      new TOutliner('h2', '#outline');
    });
  </script>

  <title>知能プログラミング演習IIグループ作成 レポート</title>
</head>

<!-- このグループ作成資料は，同じファイルを全員のGrepX（Grep5やGrep6等）ディレクトリにコピーして置くこと -->

<body>
<header>
  <!-- グループ番号を書く．-->
  <h1>グループ3</h1>

  <!-- 目次生成用 -->
  <nav id="outline"></nav>
</header>

<!-- グループ全員の名前, 学籍番号を書き，個人作成書類へのリンクを張る -->
<h2>メンバー</h2>
<ul>
<li><a href="../../../../ckl15076/workspace/kprep/rep7/index.html">鈴木祥太 27115076</a></li>
<li><a href="../../../../ckl15077/workspace/kprep/rep7/index.html">鈴木進也 27115077</a></li>
<li><a href="../../../../ckl15120/workspace/kprep/rep7/index.html">丹羽貴敏 27115120</a></li>
<li><a href="../../../../ckl15157/workspace/kprep/rep7/index.html">横尾由春 27115157</a></li>
</ul>

<h2>役割分担</h2>
<!-- 役割分担を書く．-->
<ul>
<li>鈴木祥太 27115076</a>: 課題7-5担当</li>
<li>鈴木進也 27115077</a>: 課題7-2担当</li>
<li>丹羽貴敏 27115120</a>: 課題7-3,7-5担当</li>
<li>横尾由春 27115157</a>: 課題7-1 ,課題7-7担当</li>
</ul>

<h2>ソースファイル</h2>
<ul>
	<li><a href="./Dining.java">Dining.java</a>(課題7-7)</li>
	初期状態<br>
  <li><a href="../../Planner/state.txt">state.txt</a><br>
目標状態<br>
  <li><a href="../../Planner/goal.txt">goal.txt</a><br>
  <li><a href="../../Planner/src/Planner.java">Planner.java</a>
  <li><a href="../../Planner/src/Searchplus.java">Searchplus.java</a>
  <li><a href="../../Planner/src/GraphFrame.java">GraphFrame.java</a><br>
GraphFrameを実行すればGUIが立ち上がる。<br>
    <!-- 実装・変更したソースファイルへのリンク．修正する． -->
    <!-- ※ リンクは絶対パスに変更せず，上記のような相対パスのままで！ -->
</ul>


<h2>課題7-1</h2>
[必須課題7-1] 目標状態を変えてみたときに，動作が正しくない場合があったかどうか，実行例を示して考察せよ．</br>
また，もしあったならその箇所を修正し，どのように修正したか記せ．</br>
<h3>独自仕様の説明</h3>
<!--
 もし自分で独自に決めた仕様があれば，その説明を書く．
-->

<b>問題点1</b></br>
配布されたプログラムをそのまま実行すると、"Place A on A"など、Aの上にAを置く動作が確認できる。</br>
この動作は、Aという物体が2つ以上存在しない限りあり得ない動作なのでこのエラーを修正する。</br>
<b>問題点2</b></br>
目標状態を"B on C"、"A on B"ではなく"A on B"、"B on C"のように物体の位置が上のものから入力してしまうと正しく解を得ることができない。</br>
</br>
以上2つの問題点を解決する。</br>

方針等は考察欄で記述する。</br>


<h3>プログラムの構造</h3>
<!--  どのような設計をしたか．-->
<b>問題点1</b></br>
オペレーター選択でランダムな順番に入れ替える際に、オペレーター3(ブロックの上から手への移動)が選択されず、選択されたオペレーターを最後尾ではなく3番目に代入するようにした。</br>
これにより、オペレーター3は最後尾に固定され、選ばれることはなくなる。</br>
</br>

<b>問題点2</b></br>
"○ on ○"の目標状態を抽出し、その○の集合から一度しか登場しない物体名をさらに抽出する。("A on B","B on C","C on D"ならA,D)</br>
一度しか出てこない物体のうち、後ろの○の物体を含む文を始めにゴールリストに格納する(C on D)。その後、今格納した始めの○の名前を持つ物体(C)を後ろに含む文を格納する(B on C)。その後はしりとりの要領で、始めが(A)を含む文になるまで繰り返す。</br>



<h3>実装の説明</h3>
<!--
 どう実装したか，ソースコードを詳細に説明する．
 特に重要な箇所はレポートにペーストして説明する．
-->
<b>問題点1</b></br>
ランダムな値を取得する際、0,1,2のいずれかが選択されるようにした。</br>
またリスト入れ替えの際に最後尾ではなく3番目に代入するようにした。</br>
<pre class="brush: java">
private int planningAGoal(String theGoal,Vector theCurrentState,
			Hashtable theBinding,int cPoint){
...
int randInt = Math.abs(rand.nextInt()) % (operators.size()-1);
Operator op = (Operator)operators.elementAt(randInt);
operators.removeElementAt(randInt);
operators.add(2,op);
...
}
</pre>
</br>
<b>問題点2</b></br>
今回この問題を解決するにあたって変更を加えたメソッドはinitGoalListである。</br>
必要なVectorを定義する。</br>
onGoalListは目標状態から"○ on ○"の集合が、</br>
otherListは"○ on ○"の状態が、</br>
finalGoalListはソート後のGoalList集合が格納される。</br>
<pre class="brush: java">
private Vector initGoalList(){
...
		Vector onGoalList = new Vector();
		Vector otherList = new Vector();
		Vector finalGoalList = new Vector();
}
</pre>

まず、"○ on ○"の形をもつ目標状態を抽出し、onGoalListに格納する。</br>
今回状態のなかで3wordなのは"○ on ○"のみなのでこの特性を利用している。</br>
また、"○ on ○"以外の形を持つ目標状態をotherListに格納する。</br>
<pre class="brush: java">
private Vector initGoalList(){
		for(Object s : goalList)
		{
			String str = (String)s;
			String[] tmp = str.split(" ", 0);
			if(tmp.length == 3)
			{
				onGoalList.addElement(s);
			}
			else
			{
				otherList.addElement(s);
			}
		}
</pre>

次に、onGoalList内の物体名の回数をそれぞれカウントする。</br>
<pre class="brush: java">
		Map＜String, Integer＞ m = new HashMap＜String, Integer＞();
		// Java7以降なら new HashMap<>() でOK

		for (Object s : onGoalList) {
			String str = (String)s;
			String[] tmp = str.split(" ", 0);
			for(String t : tmp){

				int v;
				if (m.containsKey(t)) {
					// Mapに登録済み
					v = m.get(t) + 1;
				} else {
					// Mapに未登録
					v = 1;
				}
				m.put((String)t, v);
			}
		}
</pre>
登場回数が1回だったものをoneListリストに記録した後、</br>
しりとりの要領で、初めと終わりが1回のものになるようにソートする。</br>
このとき、終わりが１回のものを最初に格納する。</br>
<pre class="brush: java">
		do{
			for(Object s : onGoalList)
			{
				String str = (String)s;
				String[] tmp = str.split(" ", 0);
				//			System.out.println(s);
				//			System.out.print(tmp[2]+',');
				//			System.out.println(last);

				if(Objects.equals(tmp[2],last)){
					finalGoalList.add(s);
					last = tmp[0];
					x = tmp[0];
					//	System.out.println("first="+first);
					//	System.out.println("last="+last);

				}

			}
		}while(!Objects.equals(first,x));
</pre>

<!--
  ソースコードをはりつける時は <pre> タグを使う
  class="brush: java" でシンタックスハイライトする
  重要な部分のみを貼り付ければ良い
-->



<h3>実行例</h3>
<!-- 実行例を示す．PNGやGIF等の絵を張っても良い．-->
<p>
問題例として5つの物体を動かす。</br>目標状態を"A on B","C on D","holding E","B on C"の順番で与えて実行した。</br>
以下のような解(プラン)を得た。</br>
<img src="./7-1-2.png"/>
</br>
なお10回実行してみたが全て同じ結果を得ている。</br>
</p>
<h2>課題7-2</h2>
<!-- 課題を書く．-->
教科書のプログラムでは，オペレータ間の競合解消戦略としてランダムなオペレータ選択を採用している．
これを，効果的な競合解消戦略に改良すべく考察し，実装せよ．
改良の結果，性能がどの程度向上したかを定量的に（つまり数字で）示すこと．

<h3>独自仕様の説明</h3>
<!--
 もし自分で独自に決めた仕様があれば，その説明を書く．
-->
<p>今回の課題である、オペレータの競合解消戦略として副目標のゴールがaddリストに含まれるような
オペレータの優先度を上げるという方針で競合解消を行った。</p>




<h3>プログラムの構造</h3>
<!--  どのような設計をしたか．-->
<p>
ブロック操作のプランニングを行うPlanner.javaの構造を以下に説明する。<br>
まず実際にプランニングを行うPlannerクラスはメンバ変数としてオペレータ群を管理するベクタoperators、
最終的に実行するオペレータを管理するベクタplanが宣言されている。<br>
次に定義されているメソッドについて説明する。<br>
プランニングを開始するstart()、プランニングを行うplanning()、一つのゴールに対してプランニングを行うplanningAGoal()、オペレータの変数を再定義するrename()、ゴールリストの初期化を行うinitGoalList()、初期状態の初期化を行うinitInitialState()、オペレータの初期化を行うInitOperators()<br>
最後に競合解消を行うためのConfRes0()、このメソッドは自分が新たに実装した物である。
</p>
<p>
次にオペレータについて定義しているOperatorクラスの説明をする。<br>
まず、メンバ変数としてオペレータの名前name、前件ifList、後件addList、deleteListからなる。<br>
そしてコンストラクタが定義されており、各メンバ変数の取得と削除、文字列化を行うメソッド、現在の状態にオペレータを適用させるapplyState(),変数を書き換えたオペレータを取得するgetRenamedOperator、変数束縛の適用を行うinstantiate()などからなる。
</p>

<h3>実装の説明</h3>
<!--
 どう実装したか，ソースコードを詳細に説明する．
 特に重要な箇所はレポートにペーストして説明する．
-->
<p>
  実装したプログラムに関して，planning(),planningAGoal(),ConfRes0()について説明を行う。
</p>

<p>
  下記は planning() メソッドの実装である。<br>
ゴールが一つしか状態を持たないときはそのままplanningAGoal()を呼び出す。<br>
ゴールリストが複数の要素からなる場合は、先頭から一つ要素を取り出し変数束縛と現在の状態のバックアップをとる。そして取り出したゴールについてplanningAGoalを実行する。探索に失敗したらバックアップから状態と変数束縛を復元しfalseを返す。<br>
成功した場合はtrueを返す。<br>
</p>

<!--
  ソースコードをはりつける時は <pre> タグを使う
  class="brush: java" でシンタックスハイライトする
  重要な部分のみを貼り付ければ良い
-->
<pre class="brush: java">
 private boolean planning(Vector theGoalList,
                          Vector theCurrentState,
                          Hashtable theBinding){
  System.out.println("*** GOALS ***" + theGoalList);
  if(theGoalList.size() == 1){
   String aGoal = (String)theGoalList.elementAt(0);
   if(planningAGoal(aGoal,theCurrentState,theBinding,0) != -1){
    return true;
   } else {
    return false;
   }
  } else {
   String aGoal = (String)theGoalList.elementAt(0);
   int cPoint = 0;
   while(cPoint < operators.size()){
    //System.out.println("cPoint:"+cPoint);
    // Store original binding
    Hashtable orgBinding = new Hashtable();
    for(Enumeration e = theBinding.keys() ; e.hasMoreElements();){
     String key = (String)e.nextElement();
     String value = (String)theBinding.get(key);
     orgBinding.put(key,value);
    }
    Vector orgState = new Vector();
    for(int i = 0; i < theCurrentState.size() ; i++){
     orgState.addElement(theCurrentState.elementAt(i));
    }

    int tmpPoint = planningAGoal(aGoal,theCurrentState,theBinding,cPoint);
    //System.out.println("tmpPoint: "+tmpPoint);
    if(tmpPoint != -1){
     theGoalList.removeElementAt(0);
//     System.out.println(theCurrentState);
     if(planning(theGoalList,theCurrentState,theBinding)){
      //System.out.println("Success !");
      return true;
     } else {
      cPoint = tmpPoint;
      //System.out.println("Fail::"+cPoint);
      theGoalList.insertElementAt(aGoal,0);
	  
      theBinding.clear();
      for(Enumeration e=orgBinding.keys();e.hasMoreElements();){
       String key = (String)e.nextElement();
       String value = (String)orgBinding.get(key);
       theBinding.put(key,value);
      }
      theCurrentState.removeAllElements();
      for(int i = 0 ; i < orgState.size() ; i++){
       theCurrentState.addElement(orgState.elementAt(i));
      }
     }
    } else {
     theBinding.clear();
     for(Enumeration e=orgBinding.keys();e.hasMoreElements();){
      String key = (String)e.nextElement();
      String value = (String)orgBinding.get(key);
      theBinding.put(key,value);
     }
     theCurrentState.removeAllElements();
     for(int i = 0 ; i < orgState.size() ; i++){
      theCurrentState.addElement(orgState.elementAt(i));
     }
     return false;
    }
   }
   return false;
  }
 }
</pre>
<p>次にplanningAGoal()について説明を行う。<br>
まず、ゴールの状態が現在の状態に含まれていないかを探索し、含まれている場合は終了する。<br>
含まれていなかった場合に何かしらのオペレータを実行する必要があるため、競合解消を行うためにConfRes0()を呼び出してオペレータを並べ替えておく。<br>
ここでもあらかじめ変数束縛と現在の状態集合のバックアップを取った後に各オペレータのaddリストの各要素とゴールでunifyを行う。unifyに成功した場合はその変数束縛の元でオペレータを具体化し、オペレータのifリスト新しいゴールとする。<br>そしてその新しい副目標についてplanning()を再帰的に呼び出していき、最終的に探索が成功したときそのオペレータを実行する。<br>
そのオペレータによって状態が変化するためapplyStateで現在の状態を操作後の状態に変化させる。<br>
オペレータの探索に失敗した場合はバックアップから変数束縛と状態を探索前に復元する。
</p>
<pre class="brush: java">
private int planningAGoal(String theGoal,Vector theCurrentState,
                           Hashtable theBinding,int cPoint){
  System.out.println("**"+theGoal);
  int size = theCurrentState.size();
  for(int i =  0; i < size ; i++){
   String aState = (String)theCurrentState.elementAt(i);
   if((new Unifier()).unify(theGoal,aState,theBinding)){
    return 0;
   }
  }
  /////////////////////////////////////////////////////////////
     //変更箇所
     ///////////////////////////////////////////////////////////
//  System.out.println(operators);
     ConfRes0(operators,theGoal,theBinding);
//     for(Operator op: operators){
//         System.out.println(op.name);
//     }
//  int randInt = Math.abs(rand.nextInt()) % operators.size();
//  Operator op = (Operator)operators.elementAt(randInt);
//  operators.removeElementAt(randInt);
//  operators.addElement(op);

  for(int i = cPoint ; i < operators.size() ; i++){
   Operator anOperator = rename((Operator)operators.elementAt(i));
   // 現在のCurrent state, Binding, planをbackup
   Hashtable orgBinding = new Hashtable();
   for(Enumeration e = theBinding.keys() ; e.hasMoreElements();){
    String key = (String)e.nextElement();
    String value = (String)theBinding.get(key);
    orgBinding.put(key,value);
   }
   Vector orgState = new Vector();
   for(int j = 0; j < theCurrentState.size() ; j++){
    orgState.addElement(theCurrentState.elementAt(j));
   }
   Vector orgPlan = new Vector();
   for(int j = 0; j < plan.size() ; j++){
    orgPlan.addElement(plan.elementAt(j));
   }

   Vector addList = (Vector)anOperator.getAddList();
   for(int j = 0 ; j < addList.size() ; j++){
    if((new Unifier()).unify(theGoal,
                             (String)addList.elementAt(j),
                             theBinding)){
     Operator newOperator = anOperator.instantiate(theBinding);
     Vector newGoals = (Vector)newOperator.getIfList();
     System.out.println(newOperator.name);
     if(planning(newGoals,theCurrentState,theBinding)){
    	 newOperator = newOperator.instantiate(theBinding);
        
//      System.out.println("new "+newOperator.name);
      
      plan.addElement(newOperator);
      theCurrentState =
       newOperator.applyState(theCurrentState);
      System.out.println(newOperator.name);
//      System.out.println(theCurrentState);
      
      return i+1;
     } else {
      // 失敗したら元に戻す．
      theBinding.clear();
      for(Enumeration e=orgBinding.keys();e.hasMoreElements();){
       String key = (String)e.nextElement();
       String value = (String)orgBinding.get(key);
       theBinding.put(key,value);
      }
      theCurrentState.removeAllElements();
      for(int k = 0 ; k < orgState.size() ; k++){
       theCurrentState.addElement(orgState.elementAt(k));
      }
      plan.removeAllElements();
      for(int k = 0 ; k < orgPlan.size() ; k++){
       plan.addElement(orgPlan.elementAt(k));
      }
     }
    }		
   }
  }
  return -1;
 }
</pre>
<p>
次に競合解消を行うCOnfRes0()について説明を行う。<br>
まず自分が考えた競合解消の方針は、目指すべきゴールリストを実現出来そうなオペレータの優先度を上げるという考え方である。<br>
そのため各オペレータについてaddリストを取得し、引数で与えられた変数束縛の下でゴールとunifyする。
unifyに成功したオペレータを一番上に持って行く作業を全てのオペレータについて行い最終的なオペレータのベクターを返すという物である。
</p>
<pre class="brush: java">
public void ConfRes0(Vector&ltOperator&gt operators,String thegoal,Hashtable theBinding){
	  for (int i=0;i&ltoperators.size();i++){
	      
	      Hashtable fbind = new Hashtable();
	      for(String add: operators.elementAt(i).addList){
	          
	              if ((new Unifier()).unify(add, thegoal,theBinding)) {
	                  
	                  
	              
	          
	          
	        	    Operator op = operators.elementAt(i);
	              operators.removeElementAt(i);
	              operators.add(0,op);
//	              System.out.println(fbind);
//	              break;
	          }
	      }
	  }
      
 }
</pre>
<h3>実行例</h3>
<!-- 実行例を示す．PNGやGIF等の絵を張っても良い．-->
<p>
  ここでランダムに並び替えたデフォルトの状態とConfRes0()を行ったときの比較を行うが、定量評価の指標として同じゴールと初期状態でそれぞれ10回ずつプランニングを行ったときの平均操作回数を比較する。<br>
なおその際に用いるゴールと初期状態は、以下の通りである。<br>
</p>
<h4>ゴール</h4>
<ul>
<li>B on A
<li>C on B
</ul>
<h4>初期状態</h4>
<ul>
<li>clear B
<li>clear C
<li>C on A
<li>ontable A
<li>ontable B
<li>handEmpty
</ul>
<p>そしてこのときの最適なプランは</p>
<pre>
remove C from on top A
put C down on the table
pick up B from the table
Place B on A
pick up C from the table
Place C on B
</pre>
<!-- 画像ファイルを貼る場合は <img> タグを使う -->
<table border="1">
  <tr>
    <td>戦略</td><td>平均操作回数</td>
  </tr>
  <tr>
    <td>ランダム</td><td>48.9回</td>
  </tr>
  <tr>
    <td>競合解消</td><td>6回</td>
  </tr>
</table>
<p>
以上のようにランダムなオペレータ選択では最適な操作回数の8倍以上も平均で必要になっている一方で、
競合解消を行うと毎回最適な操作を行うことが出来ている。
</p>


<h2>考察</h2>
<!--
 考察を書く．PNGやGIF等の絵を張っても良い．
 例: 自分で工夫して解決した点，その解決手法，なぜそうしたのか，その手法の素晴らしさ，上手くいかなかった点，なぜ上手くいかなかったのか，など．
 例: 今回はできなかったが，更に〜の機能を追加すべきである．なぜなら，...
-->
<p>
  今回、競合解消戦略として自分はゴール状態を最も満足させられるような操作を選択するというアプローチを選んだ。この戦略で、テーブルに置かれてるブロックを積み上げていくことは最適な操作でゴールにたどり着くことができるようになったのだが、その逆で初期状態にブロックが積みあがった状態で、最終的にすべてのブロックがテーブルに置かれた状態をゴールとして目指すというのはできなかった。<br>
  具体的に言うと積みあがったブロックを持ち上げてテーブルに置くという段階で副目標が無限ループに陥ってしまい再帰が終わらなくなってしまった。<br>
  原因として考えられるのは、競合解消のためのオペレータを並べ替える段階で目標によって並びが固定されてしまうために副目標が永遠に解決されないことだと推測した。<br>
  そのためブロック操作というテーマにおいて自分の考えた競合解消戦略は不完全だった、これとは別に二つ競合解消戦略を実装したかったが時間と構想を思いつくことができず断念したものがある。<br>
  それがLEXとMEAである。この二つの戦略はインスタンシエーションにタイムタグを導入し、そのタイムタグの最新性を利用するものである。<br>
  今回でいうとオペレータごとにいつその操作がなされたかという時系列がわかるような機構を用意しておき、それを基に競合したオペレータを並び替えるというものである。この方針であれば目標状態と比較するだけでなく最も新しく行われた操作が選ばれるためヒューリスティックス的なアプローチではあるがより柔軟なブロック操作のプランニングができるのではないかと考える。<br>
  ただ、今回のオペレータの探索は後ろ向き推論を利用したものだが、LEXやMEAといった戦略は前向き推論がベースとなっているためどう実装していいかわからなかった。<br>
  ほかにも二つ前に実行されたオペレータを記憶しておき、変数束縛で具体化して全く同じオペレータが選択されようとしていたらそのオペレータの優先度を下げるといった工夫もできるのではないかと実装してみたがplace A on Aという本来してはならない操作が表れてしまいうまくいかなかった。<br>
  競合解消戦略ではないが、オペレータのstateの表記にも改善できる部分があると感じた。<br>
  具体的に言うと、holding ?x という状態が、テーブルから持ち上げたのかブロックに乗った状態から持ち上げたのかわからず一緒くたになっているために競合が起きていると考える。
  この状態を細分化し、holding ?x from tableとholding ?x from ?yの二つの状態で記述するようにすれば、ある程度操作を最適化できるのではないか。<br>
  以上のことから、操作が競合したときの戦略を考えることも重要だが、不必要な競合が起きないような状態の記述の仕方を心がけることもプランニングをするうえで大切だと思った。<br>
</p>


<h2>課題7-3</h2>
<!-- 課題を書く．-->
上記7-2で改良したプランニングシステムのGUIを実装せよ．<br>
ブロック操作の過程をグラフィカルに可視化し，初期状態や目標状態をGUI上で変更できることが望ましい． <br>
<h3>独自仕様の説明</h3>
<!--
 もし自分で独自に決めた仕様があれば，その説明を書く．
-->
ファイル名を入力してロードボタンを押すとテキストエリアに内容が表示される。<br>
テキストエリアに内容を書き込んだり削除したりしてセーブボタンを押すと内容が保存される。<br>
プランニング実行ボタンを押すとテキストエリアにプランが表示される。<br>
状態図生成ボタンを押すと別枠で図が表示され、次へボタンを押すとプランを順に実行していく。<br>
<h3>プログラムの構造</h3>
<!--  どのような設計をしたか．-->
追加した部分のみ記載する。<br>
GraphFrameではGUIを作成している。<br>
actionPerformedメソッドではボタンがクリックされたときの動作について書いてある。<br>
Searchplusでは現在の状態のブロックを表示している。<br>
Plannerクラスでは新たにplandoingメソッド、getblockメソッド、start2メソッド、restartメソッド、initGoalListfileメソッド、initInitialStatefileメソッドを追加した。<br>
plandoingメソッドは引数に現在の状態のベクターと実行するプランをString型でとりプラン実行後のベクターを返す。<br>
getblockメソッドは現在のブロックの状態をArrayListにして返すものである。<br>
start2メソッドは初期状態、目標状態のファイル名をString型でとり、ファイルから読み込むようにしてある。<br>
restartメソッドは目標状態のファイル名と現在の状態を引数にとり現在の状態から再度プランニングを行うものである。<br>
initGoalListfileメソッドは引数にString型の変数をとり、そのファイルからgoalListを読み込んでいる。<br>
initInitialStatefileメソッドは引数にString型の変数をとり、そのファイルからinitialStateを読み込んでいる。<br>
<h3>実装の説明</h3>
<!--
 どう実装したか，ソースコードを詳細に説明する．
 特に重要な箇所はレポートにペーストして説明する．
-->
actionPerformedメソッドではセーブボタンが押されたときは
<pre class="brush:java">
			if (rulefilename.getText().equals("")) {
				error.setText("Please write rulelist-filename");
				dialog.setVisible(true);
			} else {
				try {
					String filename = rulefilename.getText();
					BufferedWriter in = new BufferedWriter(
							new OutputStreamWriter(new FileOutputStream(
									filename), "UTF-8"));
					String[] s = rule.getText().split("\n");
					rulelist.clear();
					for (String str : s) {
						rulelist.add(str);
					}
					for (String str : rulelist) {
						in.write(str);
						in.newLine();
					}
					in.close();
				} catch (IOException e) {
					error.setText("Error!!");
					dialog.setVisible(true);
				}
			}
</pre>
ファイル名がなければそのことを表示させて、ファイル名があった場合は一行ずつ配列に文章をいれる。<br>
それをリストに入れてファイルに書き込んでいる。<br>
ロードボタンが押されたとき
<pre class="brush:java">
			if (rulefilename.getText().equals("")) {
				error.setText("Please write filename");
				dialog.setVisible(true);
			} else {
				try {
					String filename = rulefilename.getText();
					BufferedReader in = new BufferedReader(
							new InputStreamReader(
									new FileInputStream(filename), "UTF-8"));
					rulelist.clear();
					for (String line = in.readLine(); line != null; line = in
							.readLine()) {
						rulelist.add(line);
					}
					rule.setText("");
					for (String s : rulelist) {
						rule.append(s + "\n");
					}
				} catch (IOException e) {
					error.setText("File is not exist");
					dialog.setVisible(true);
				}
			}
</pre>
ファイル名が入力されていないときはセーブのときと同じである。<br>
一度リストをクリアして新しくファイルから読み込みを行っている。<br>
その後テキストを一端からにして1つずつテキストに改行しながら書き込みを行っている。<br>
<pre class="brush:java">
			if (asfilename.getText().equals("")
					|| rulefilename.getText().equals("")) {
			} else {
				try{
				String filename = asfilename.getText();
				String filename1 = rulefilename.getText();
				BufferedReader in = new BufferedReader(
						new InputStreamReader(
								new FileInputStream(filename), "UTF-8"));
				aslist.clear();
				for (String line = in.readLine(); line != null; line = in
						.readLine()) {
					aslist.add(line);
				}
				as.setText("");
				for (String str : aslist) {
					System.out.println(str);
					as.append(str + "\n");
				}
				BufferedReader in1 = new BufferedReader(
						new InputStreamReader(
								new FileInputStream(filename1), "UTF-8"));
				rulelist.clear();
				for (String line = in1.readLine(); line != null; line = in1
						.readLine()) {
					rulelist.add(line);
				}
				rule.setText("");
				for (String s : rulelist) {
					rule.append(s + "\n");
				}
				Planner.start2(filename, filename1);
				Img.setText("");
				for (int i = 0; i < Planner.plan.size(); i++) {
					Operator op = (Operator) Planner.plan.elementAt(i);
					Img.append((String) op.instantiate(Planner.re).name + "\n");
				}
				}
				catch (IOException e) {
					error.setText("File is not exist");
					dialog.setVisible(true);
				}
			}
		} 
</pre>
初期状態、目標状態のファイル名がちゃんと書き込まれている場合はそこからプランニングを行い、得られたプランをテキストエリアに書き込んでいる。<br>
状態図生成ボタンが押されたとき
<pre class="brush:java">
				try {
					counter = 0;
					String filename = asfilename.getText();
					String filename1 = rulefilename.getText();
					BufferedReader in = new BufferedReader(
							new InputStreamReader(
									new FileInputStream(filename), "UTF-8"));
					aslist.clear();
					for (String line = in.readLine(); line != null; line = in
							.readLine()) {
						aslist.add(line);
					}
					as.setText("");
					for (String str : aslist) {
						System.out.println(str);
						as.append(str + "\n");
					}
					BufferedReader in1 = new BufferedReader(
							new InputStreamReader(
									new FileInputStream(filename1), "UTF-8"));
					rulelist.clear();
					for (String line = in1.readLine(); line != null; line = in1
							.readLine()) {
						rulelist.add(line);
					}
					rule.setText("");
					for (String s : rulelist) {
						rule.append(s + "\n");
					}

					Planner.start2(filename, filename1);
					Planner.state = Planner.initInitialStatefile(filename);
					Planner.getblock(Planner.state);
					Img.setText("");
					for (int i = 0; i < Planner.plan.size(); i++) {
						Operator op = (Operator) Planner.plan.elementAt(i);
						Img.append((String) op.instantiate(Planner.re).name
								+ "\n");
					}
					Searchplus app = new Searchplus();
					JScrollPane a = new JScrollPane(app);
					a.setBounds(1000, 1000, 1000, 1000);
					frame4.setVisible(false);
					frame4 = new JFrame();
					frame4.add(a);
					frame4.add(move, BorderLayout.NORTH);
					frame4.pack();
					frame4.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
					frame4.setVisible(true);
				} catch (IOException e) {
					error.setText("File is not exist");
					dialog.setVisible(true);
				}
				flag = false;

			}
</pre>
テキストエリアからファイル名を読み込んでプランニングを実行する。<br>
初期状態を設定して、最初なのでgetblockメソッドによりブロックの最初の状態をArrayListに変換する。<br>
プランニングの結果をテキストエリアに表示させてブロック状態の画像表示を行っている。<br>
次へボタンが押された際は
<pre class="brush:java">
			if (counter < Planner.doplan.size()) {
				k = Planner.plandoing(Planner.doplan.get(counter),
						Planner.state);
				counter++;
				System.out.println(Planner.state);
				Searchplus app = new Searchplus();
				JScrollPane a = new JScrollPane(app);
				a.setBounds(1000, 1000, 1000, 1000);
				frame4.add(a);
				frame4.add(move, BorderLayout.NORTH);
				frame4.pack();
				frame4.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
				frame4.setVisible(true);
			}
</pre>
if文では実行可能なプランを順番に試している。<br>
その後図を再描画している。<br>
SearchplusのpaintComponetメソッドでは最初にブロックの状態を記録したArrayListをもってくる。<br>
<pre class="brush:java">
		for (int j = 0; j < i; j++) {
			ArrayList&ltString&gt nameline = namelist.get(j);
			//System.out.println(nameline);
			int y = 90;
			int high = 0;
			for (String s : nameline) {
				g2.draw(new Rectangle2D.Double(j * 300.0d, (Planner.name.size() * 190.0 - x) * 1.0 - (y * high) * 1.0d,
						160.0d, 90.0d));
				g2.drawString(s, j * 300 + 70, Planner.name.size() * 190 - x + 40 - high * 90);
				high++;
			}
		}
</pre>
ブロックの状態を1列ずつ取り出す。<br>
取り出したArrayListに対して1つずつ要素を取り出して四角形とブロック名を表示させる。<br>
<pre class="brush:java">
		g2.draw(new Rectangle2D.Double(300.0d, (Planner.name.size() * 190.0-x + 130) * 1.0d, 160.0d, 90.0d));
		g2.drawString("holding", 300, (Planner.name.size() * 190 -x + 120) * 1);
		if (!Planner.hold.equals("")) {
			g2.drawString(Planner.hold, 300 + 50, (Planner.name.size() * 190 -x+170) * 1);
		}
</pre>
上2つは手に持っているブロックを表示させるための枠と文字である。<br>
String型変数holdには手に持っているブロック名が記述されているのでもし存在すれば表示する。<br>
<pre class="brush:java">
		g2.draw(new Line2D.Double(0.0d, Planner.name.size() * 190.0d-x+90.0d, Planner.name.size() * 300.0d,
				Planner.name.size() * 190.0d-x+90.0d));
</pre>
ここではブロックの最下層に線を引いてテーブルを表現している。<br>
plandoingメソッドは実行されるプランは今回4種類のみなので正規表現をもちいてどのパターンなのかを分類する。<br>
まずPlace x on yのとき<br>
<pre class="brush:java">
			String x =mat1.group(1);
			String y =mat1.group(2);
			String check = "clear "+y;
			String check1= "holding "+x;
</pre>
正規表現により該当するブロック名を持ってくる。<br>
clear yとholding xを削除する必要があるのでString型の変数に入れてある。<br>
<pre class="brush:java">

			 for(int j = 0 ; j < now.size() ; j++){
				 String a = (String)now.get(j);
				 boolean flag = true;
				 if(a.equals(check)){
					 flag=false;
				 }
				 if(a.equals(check1)){
					 flag=false;
				 }
				 if(flag){
					 re.addElement(a);
				 }
			 }
</pre>
現在の状態を１つずつ取り出して、もしdeleteするものならflagをfalseにして返却するVectorに入れないようにしてある。<br>
<pre class="brush:java">
			 hold ="";
			 for(int i =0; i < namelist.size();i++){
				 ArrayList&ltString &gt memo = namelist.get(i);
				 if(memo.contains(y)){
					 memo.add(x);
				 }
				 namelist.remove(i);
				 namelist.add(i,memo);
			 }
</pre>
このオペレータでは手に持ったブロックをおくので持っているブロックの名前を削除する。<br>
またブロックがおかれている状態のリストを取り出して下のブロックがあるところのリストに上のブロックを追加している。<br>
<pre class="brush:java">
				re.addElement(x+" on "+y);
				re.addElement("clear "+x);
				re.addElement("handEmpty");
</pre>
ここではaddするものを追加している。<br>
remove x from on top yのとき<br>
状態の削除、追加のやり方は先ほどと同じなので説明を省略する。<br>
ブロック操作では
<pre class="brush:java">
			 hold = y;
			 for(int i =0; i < namelist.size();i++){
				 ArrayList&ltString &gt memo = namelist.get(i);
				 if(memo.contains(y)){
					 for(int j =0; j < memo.size();j++){
						String s = memo.get(j);
						if(s.equals(x)){
							memo.remove(j);
						}
					 }
				 }
				 namelist.remove(i);
				 namelist.add(i,memo);
			 }

</pre>
リストの順番に取り出してxがあったらそこを取り除くものである。<br>
pick up x from the tableのとき<br>
状態の削除、追加のやり方は先ほどと同じなので説明を省略する。<br>
ブロック操作では
<pre class="brush:java">
			 hold =x;
			 for(int i =0; i < namelist.size();i++){
				 ArrayList&ltString &gt memo = namelist.get(i);
				 if(memo.contains(x)){
					 memo.remove(0);
				 }
				 namelist.remove(i);
				 namelist.add(i,memo);
			 }
</pre>
xが含まれていたら取り除くようになっている。<br>
put x down on the tableのとき<br>
状態の削除、追加のやり方は先ほどと同じなので説明を省略する。<br>
ブロック操作では
<pre class="brush:java">
			for (int i = 0; i < namelist.size(); i++) {
				ArrayList&ltString&gt memo = namelist.get(i);
				if (memo.size() == 0) {
					memo.add(x);
					namelist.remove(i);
					namelist.add(i, memo);
　　　　　　　　　　　　　　　　　　　　break;
				}
			}
</pre>
tableにおくのでサイズが0であるリストに追加している。<br>
追加は1回だけなのでbreakしている。<br>
getblockメソッドではまずontable x とholding yのブロックを探す。<br>
初期状態に対してチェックを行う。<br>
<pre class="brush:java">
			if (mat1.find()) {
				String name1 = mat1.group(1);
				if (!name.contains(name1)) {
					name.add(name1);
					ArrayList&ltString&gt n = new ArrayList&ltString&gt();
					n.add(name1);
					namelist.add(n);

				}
			} else if (mat2.find()) {
				String name1 = mat2.group(1);
				hold = name1;
				if (!name.contains(name1)) {
					name.add(name1);
				}
			}
		}
</pre>
ontableに対してはnameという名前リストに追加して新しくArrayListを新しく作成してそれをnamelistに保存している。<br>
holdingに対してはholdというString型変数に保存してnameに保存している。<br>
<pre class="brush:java">
		boolean check = true;
		while (check) {
			check = false;
			for (int i = 0; i < initialState.size(); i++) {
				String state = (String) initialState.elementAt(i);
				Pattern pat1 = Pattern.compile("(.+) on (.+)");
				Matcher mat1 = pat1.matcher(state);
				if (mat1.find()) {
					String name1 = mat1.group(1);
					String name2 = mat1.group(2);
					if (!name.contains(name1)) {
						for (int j = 0; j < namelist.size(); j++) {
							ArrayList&ltString&gt a = namelist.get(j);
							if (a.contains(name2) && !a.contains(name1)) {
								namelist.remove(j);
								check = true;
								name.add(name1);
								a.add(name1);
								namelist.add(j, a);
							}
						}
					}
				}
			}
		}
</pre>
ここではnameの変更がなくなるまで状態のチェックを行っている。<br>
上の方になっているブロックの名前を追加し、namelistに追加をしている。<br>
またこのように変更のした場合はbooleanをtrueに変更してwhile文が続くようにしている。<br>
リストが変わらなくなったら
<pre class="brush:java">
		for (int i = namelist.size(); i < name.size(); i++) {
			ArrayList&ltString&gt a = new ArrayList&ltString&gt();
			namelist.add(a);
		}
</pre>
ここでは空のリストをnamelistに追加している。<br>
start2メソッドでは
<pre class="brush:java">
		Vector goalList = initGoalListfile(goalfile);
		Vector initialState = initInitialStatefile(infile);

</pre>
ここでファイル名から目標状態と初期状態を読み込んでいる。<br>
プランニングを行った後は
<pre class="brush:java">
		re.clear();
		for (Enumeration e = theBinding.keys(); e.hasMoreElements();) {
			String key = (String) e.nextElement();
			String value = (String) theBinding.get(key);
			re.put(key, value);
		}
		doplan.clear();
		for (int i = 0; i < plan.size(); i++) {
			Operator op = (Operator) plan.elementAt(i);
			System.out.println((op.instantiate(theBinding)).name);
			doplan.add((op.instantiate(theBinding)).name);
		}
</pre>
ここでハッシュテーブルをコピーして、プランを保存している。<br>
restartメソッドでは初期状態を引数で与えてもらって再度プランニングをしているだけである。<br>
initGoalListfileメソッド、initInitialStatefileメソッドではファイルから読み込んだ行を1行ずつVectorに追加しているだけなので説明を省略する。<br>
<h3>実行例</h3>
<!-- 実行例を示す．PNGやGIF等の絵を張っても良い．-->
<img src = "taka1.png"><br>
この状態で状態図の動きを見てみる。<br>
<img src = "taka2.png" width = "600" height="400">
<img src = "taka3.png"width = "600" height="400">
<img src = "taka4.png"width = "600" height="400">
<img src = "taka5.png"width = "600" height="400">
<img src = "taka6.png"width = "600" height="400">
<img src = "taka7.png"width = "600" height="400"><br>
プラン通りの動きをしており結果が正しいことがわかる。<br>


<h2>発展課題7-5</h2>
ユーザが自然言語（日本語や英語など）の命令文によってブロックを操作したり，初期状態／目標状態を変更したりできるようにせよ．<br>
なお，命令文の動詞や語尾を１つの表現に決め打ちするのではなく，多様な表現を許容できることが望ましい．

<h3>独自仕様の説明</h3>
<!--
 もし自分で独自に決めた仕様があれば，その説明を書く．
-->
<p>課題に加えて，以下の五点を独自仕様として組み込んだ．</p>

<ol>
  <li>ユーザの自然言語は英語の命令文とする</li>
  <li>初期状態と目標状態はファイルから読み込む</li>
  <li>プランニングの過程をコンソールで示す</li>
  <li>ブロック操作を行う命令文はプランニングの過程を示しているときに読み込む</li>
  <li>初期状態と目標状態の変更を行う命令文はプランニングを行う前に実行する</li>
</ol>

<p>
  1.に関して，ユーザから入力される自然言語は英語とし，その英語の構造により各操作を実行する仕様とした．
</p>
<p>
  2.に関して，初期状態と目標状態を初期化する際に，それぞれ InitialState.data, GoalList.data から読み込む仕様とした．
</p>
<p>
  3.に関して，プログラム実行後にenterキーを押すとプランニングの過程が1ステップずつ実行される仕様とした．
</p>
<p>
  4.に関して，プログラム実行後にブロック操作を行う命令文を入力してenterキーを押すと，その時点の状態に対してブロック操作が行われる仕様とした．
</p>
<p>
  5.に関して，初期状態と目標状態の変更を行う命令文はプランニング実行前に changeInitialState(), changeGoalList() メソッドにより処理する仕様とした．
</p>


<h3>プログラムの構造</h3>
<!--  どのような設計をしたか．-->
<p>
  実装したプログラムは三つのクラス Planner, Operator, Unifier で構成されている．
</p>

<h4>Plannerクラス</h4>
<p>
  Planner クラスは main メソッド，コンストラクタ，インスタンスメソッドとして start(), restart(), checkOrder(), nextStep(), changeInitialState(), changeGoalList(), planning(), planningAGoal(), rename(), initGoalList(), initInitialState(), initOperators() を持つ．<br>
  main メソッドは，プランニングを実行する．<br>
  コンストラクタ は，Planner クラスのインスタンスを生成する．<br>
  start() メソッドは，初期状態と目標状態を初期化してプランニングを実行した結果を出力する．<br>
  restart() メソッドは引数としてクラス Vector 型の変数 initialState, クラス Vector 型の変数 goalList を取り，引数として与えられた initialState を初期状態，goalList を目標状態とするプランニングを実行した結果を出力する．<br>
  checkOrder() メソッドは引数としてクラス Vector 型の変数 nowState, クラス String 型の変数 op を取り，引数として与えられた nowState に対してオペレータ op が実行できるなら戻り値として true を返し，実行できないなら戻り値として false を返す．<br>
  nextStep() メソッドは引数としてクラス Vector 型の変数 now, クラス String 型の変数 plan1 を取り，引数として与えられた初期状態 now に対してオペレータ plan1 を実行した後の状態を戻り値として返す．<br>
  changeInitialState() メソッドは引数としてクラス Vector 型の変数 initialState, クラス String 型の変数 order を取り，引数として与えられた自然言語の命令文 order によって初期状態 initialState を変更したものを戻り値として返す．<br>
  changeGoalList() メソッドは引数としてクラス Vector 型の変数 goalList, クラス String 型の変数 order を取り，引数として与えられた自然言語の命令文 order によって目標状態 goalList を変更したものを戻り値として返す．<br>
  planning() メソッドは引数としてクラス Vector 型の変数 theGoalList, クラス Vector 型の変数 theCurrentState, クラス Hashtable 型の変数 theBinding を取り，引数として与えられた現在の状態 theCurrentState から目標状態 theGoalList に変換するようなプランの探索が成功したら戻り値として true を返し，失敗したら戻り値として false を返す．<br>
  planningAGoal() メソッドは引数としてクラス String 型の変数 theGoal, クラス Vector 型の変数 theCurrentState, クラス Hashtable 型の変数 theBinding, int 型の変数 cPoint を取り，引数として与えられた現在の状態 theCurrentState から 目標状態の一つ theGoal に変換するようなプランの探索が成功したら戻り値として 0 か 適用したオペレータのインデックス を返し，失敗したら戻り値として -1 を返す．<br>
  rename() メソッドは引数としてクラス Operator 型の変数 theOperator を取り，引数として与えられたオペレータ theOperator をリネーミングしたものを戻り値として返す．<br>
  initGoalList() メソッドは，目標状態を初期化したものを戻り値として返す．<br>
  initInitialState() メソッドは，初期状態を初期化したものを戻り値として返す．<br>
  initOperators() メソッドは，オペレータを定義する．
</p>

<h4>Operatorクラス</h4>
<p>
  Operator クラスは コンストラクタ，インスタンスメソッドとして getAddList(), getDeleteList(), getIfList(), toString(), applyState(), getRenamedOperator(), getVars(), makeRenamedVarsTable(), renameVars(), instantiate(), instantiateString(), var() を持つ．<br>
  コンストラクタ は引数としてクラス String 型の変数 theName, クラス Vector 型の変数 theIfList, クラス Vector 型の変数 theAddList, クラス Vector 型の変数 theDeleteList を取り，Operator クラスのインスタンスを生成する．<br>
  getAddList() メソッドは，Operator クラスのメンバ変数である addList を戻り値として返す．<br>
  getDeleteList() メソッドは，Operator クラスのメンバ変数である deleteList を戻り値として返す．<br>
  getIfList() メソッドは，Operator クラスのメンバ変数である ifList を戻り値として返す．<br>
  toString() メソッドは，Operator クラスのメンバ変数である name, addList, deleteList, ifList を文字列としたものを戻り値として返す．<br>
  applyState() メソッドは引数としてクラス Vector 型の変数 theState を取り，引数として与えられた theState へメンバ変数である addList の要素を加え，deleteList の要素を削除したものを戻り値として返す．<br>
  getRenamedOperator() メソッドは引数として int 型の変数 uniqueNum を取り，Operator クラスのインスタンスの変数をリネーミングしたものを戻り値として返す．<br>
  getVars() メソッドは引数としてクラス String 型の変数 thePattern, クラス Vector 型の変数 vars を取り，引数として与えられた thePattern に含まれる変数を vars に格納したものを戻り値として返す．<br>
  makeRenamedVarsTable() メソッドは引数としてクラス Vector 型の変数 vars, int 型の変数 uniqueNum を取り，引数として与えられた vars に含まれる各変数に対応した新たな唯一の名前を生成し，元の名前と新たな名前が対応するようにクラス Hashtable 型の変数 result に格納して，それを戻り値として返す．<br>
  renameVars() メソッドは引数としてクラス String 型の変数 thePattern, クラス Hashtable 型の変数 renamedVarsTable を取り，引数として与えられた thePattern に含まれる変数名を新たな変数名に置き換えたものを戻り値として返す．<br>
  instantiate() メソッドは引数としてクラス Hashtable 型の変数 theBinding を取り，引数として与えられた theBinding に従って，オペレータを具体化したものを戻り値として返す．<br>
  instantiateString() メソッドは引数としてクラス String 型の変数 thePattern, クラス Hashtable 型の変数 theBinding を取り，引数として与えられた thePattern 中の変数を theBinding に格納されている値に置き換えたものを戻り値として返す．<br>
  var() メソッドは引数としてクラス String 型の変数 str1 を取り，引数として与えられた str1 が変数なら戻り値として true を返し，変数でないなら戻り値として false を返す．
</p>

<h4>Unifierクラス</h4>
<p>
  Unifier クラスは コンストラクタ，インスタンスメソッドとして 3引数のunify(), 2引数のunify(), tokenMatching(), varMatching(), replaceBuffer(), replaceBindings(), var() メソッドを持つ．<br>
  コンストラクタ は，Unifier クラスのインスタンスを生成する．<br>
  3引数のunify() メソッドは引数としてクラス String 型の変数 string1, クラス String 型の変数 string2, クラス HashMap 型の変数 theBindings を取り，戻り値として 2引数のunify() が成功したら true を，失敗したら false を返す．<br>
  2引数のunify() メソッドは引数としてクラス String 型の変数 string1, クラス String 型の変数 string2 を取り，戻り値としてパターンマッチングが成功したら true を，失敗したら false を返す．<br>
  tokenMatching() メソッドは引数としてクラス String 型の変数 token1, クラス String 型の変数 token2 を取り，戻り値として tokn1 と token2 のパターンマッチングに成功したら true を，失敗したら false を返す．<br>
  varMatching() メソッドは引数としてクラス String 型の変数 vartoken, クラス String 型の変数 token を取り，戻り値として vartoken と token のパターンマッチングに成功したら true を，失敗したら false を返す．<br>
  replaceBuffer() メソッドは引数としてクラス String 型の変数 preString, クラス String 型の変数 postString を取り，bufferに存在するpreStringという名前の変数を全てpostStringという定数に置き換える．<br>
  replaceBindings() メソッドは引数としてクラス String 型の変数 preString, クラス String 型の変数 postString を取り，preStringをハッシュ値として持つキーのハッシュ値をpostStringに変更する．<br>
  var() メソッドは引数としてクラス String 型の変数 str1 を取り，str1が変数なら戻り値としてtrueを返す．
</p>
<h4>GraphFrameクラス</h4>
<p>
actionPerformedメソッドにボタンを追加した。<br>
</p>

<h3>実装の説明</h3>
<!--
 どう実装したか，ソースコードを詳細に説明する．
 特に重要な箇所はレポートにペーストして説明する．
-->
<h4>Plannerクラス</h4>
<p>
  実装したプログラムに関して，先に挙げた Planner クラスが持つ main メソッド，コンストラクタ，start(), restart(), chackOrder(), nextStep(), changeInitialState(), changeGoalList(), planning(), planningAGoal(), rename(), initGoalList(), initInitialState(), initOperators() メソッドの説明を行う．
</p>
<p>
  main メソッドについて特筆すべき点は，自クラスのインスタンスを生成して，自クラスの start() メソッドによりプランニングを実行していることである．
</p>
<p>
  コンストラクタについて特筆すべき点は，競合解消戦略に使用する乱数であるクラス Random 型の rand をインスタンス化していることである．
</p>
<p>
  下記は start() メソッドの実装である．ここで特筆すべき点は，命令文によってブロックを捜査するときのために実行前の初期状態・目標状態を保存していることである．保存するときにコンストラクタの引数に goalList, initialState を与えることにより，goalList, initialState が変更されてもそれを保存したものは変更されないようにしている．ユーザの自然言語の命令文に in initialState が含まれていたら初期状態を変更し，in goalList が含まれていたら目標状態を変更している．プランニングの実行後，その結果を出力する際に一行ずつ出力し，returnキーが押されたらもう一行出力し，命令文が与えられたら restart() メソッドによりその時点の状態に対するブロックの操作をするようにしている．
</p>
<pre class="brush: java">
  public void start() {
      initOperators();
      Vector goalList = initGoalList();
      Vector initialState = initInitialState();

      // 実行前の初期状態・目標状態を保存 newで宣言しないとダメ
      Vector tmpGoalList = new Vector(goalList);
      Vector tmpInitialState = new Vector(initialState);

      // 自然言語の命令文
      String order = "add A on B in goalList"; // ブロックの操作，初期・目標状態の変更の両方
//        String orderBlock = "Put A on B"; // ブロックの操作
//        String orderState = "Put A ontable"; // 初期・目標状態の変更

      // 命令文によりブロックを操作，初期・目標状態を変更
      if (order.contains("in initialState")) { // 初期状態を変更
          String orderInitialState = order.substring(0, order.indexOf("in initialState") - 1);
//            System.out.println(orderInitialState);
          initialState = changeInitialState(initialState, orderInitialState);
      } else if (order.contains("in goalList")) { // 目標状態を変更
          String orderGoalList = order.substring(0, order.indexOf("in goalList") - 1);
//            System.out.println(orderGoalList);
          goalList = changeGoalList(goalList, orderGoalList);
      }

      Hashtable theBinding = new Hashtable();
      plan = new Vector();
      planning(goalList, initialState, theBinding);

      System.out.println("***** This is a plan! *****");
      for (int i = 0; i < plan.size(); i++) {
          Operator op = (Operator) plan.elementAt(i);
          System.out.println((op.instantiate(theBinding)).name);
      }

      System.out.println(initialState);
      System.out.println(goalList);
      System.out.println(theBinding);

      // 実行前の初期状態・目標状態を復元
      goalList = tmpGoalList;
      initialState = tmpInitialState;
      System.out.println(initialState);
      boolean fin = true;
      String operateOrder;
      for (int i = 0; i < plan.size(); i++) {
          Operator op = (Operator) plan.elementAt(i);
          System.out.print((op.instantiate(theBinding)).name);

          // ここに状態の変更を行うメソッドを記述
          initialState = nextStep(initialState, op.toString());
          System.out.println(initialState);

          // enterの読み込み
          Scanner scan = new Scanner(System.in);
          operateOrder = scan.nextLine();
          if (!operateOrder.isEmpty()) {
              System.out.println("new operator: " + operateOrder);
              if (checkOrder(initialState, operateOrder)) {
                  initialState = nextStep(initialState, operateOrder);
                  fin = false;
                  break;
              } else {
                  System.out.println("Cannot Operate");
                  break;
              }
          }
      }
      if (!fin) { // 途中で命令が入力された
          System.out.println("Re Planning");
          plan.clear();
          restart(initialState, goalList); // プランニングをもう一度実行
      }
  }
</pre>
<p>
  下記は restart() メソッドの実装である．ここで特筆すべき点は，start() メソッドと同様に命令文によってブロックを捜査するときのために実行前の初期状態・目標状態を保存していることである．保存するときにコンストラクタの引数に goalList, initialState を与えることにより，goalList, initialState が変更されてもそれを保存したものは変更されないようにしている．プランニングの実行後も start() メソッドと同様の処理を行っているが，命令文が与えられたら restart() メソッドを再帰的に呼び出している．
</p>
<pre class="brush: java">
  public void restart(Vector initialState, Vector goalList) {
      // 実行前の初期状態・目標状態を保存 newで宣言しないとダメ
      Vector tmpGoalList = new Vector(goalList);
      Vector tmpInitialState = new Vector(initialState);

      Hashtable theBinding = new Hashtable();
      plan = new Vector();
      planning(goalList, initialState, theBinding);

      System.out.println("***** This is a plan! *****");
      for (int i = 0; i < plan.size(); i++) {
          Operator op = (Operator) plan.elementAt(i);
          System.out.println((op.instantiate(theBinding)).name);
      }

      System.out.println(initialState);
      System.out.println(goalList);
      System.out.println(theBinding);

      // 実行前の初期状態・目標状態を復元
      goalList = tmpGoalList;
      initialState = tmpInitialState;
      System.out.println(initialState);
      boolean fin = true;
      String operateOrder;
      for (int i = 0; i < plan.size(); i++) {
          Operator op = (Operator) plan.elementAt(i);
          System.out.print((op.instantiate(theBinding)).name);

          // ここに状態の変更を行うメソッドを記述
          initialState = nextStep(initialState, op.toString());
          System.out.println(initialState);

          // enterの読み込み
          Scanner scan = new Scanner(System.in);
          operateOrder = scan.nextLine();
          if (!operateOrder.isEmpty()) {
              System.out.println("new operator: " + operateOrder);
              if (checkOrder(initialState, operateOrder)) {
                  initialState = nextStep(initialState, operateOrder);
                  fin = false;
                  break;
              } else {
                  System.out.println("Cannot Operate");
                  break;
              }
          }
      }
      if (!fin) { // 途中で命令が入力された
          System.out.println("Re Planning");
          plan.clear();
          restart(initialState, goalList); // プランニングをもう一度実行
      }
  }
</pre>
<p>
  下記は checkOrder() メソッドの実装である．ここで特筆すべき点は，オペレータのパターンを4つ用意して正規表現によるマッチングを使用していることである．それぞれマッチングしたオペレータに対する処理の中では boolean 型の flag により，引数として与えられた状態に対してオペレータが実行できるか否かを管理している．
</p>
<pre class="brush: java">
  public boolean checkOrder(Vector nowState, String op) {
      Pattern pat1 = Pattern.compile("Place (.+) on (.+)");
      Matcher mat1 = pat1.matcher(op);
      Pattern pat2 = Pattern.compile("remove (.+) from on top (.+)");
      Matcher mat2 = pat2.matcher(op);
      Pattern pat3 = Pattern.compile("pick up (.+) from the table");
      Matcher mat3 = pat3.matcher(op);
      Pattern pat4 = Pattern.compile("put (.+) down on the table");
      Matcher mat4 = pat4.matcher(op);
      if (mat1.find()) {
          String x = mat1.group(1);
          String y = mat1.group(2);
          String check1 = "clear " + y;
          String check2 = "holding " + x;
          boolean flag1 = false;
          boolean flag2 = false;
          for (int j = 0; j < nowState.size(); j++) {
              String a = (String) nowState.get(j);
              if (a.equals(check1)) {
                  flag1 = true;
              }
              if (a.equals(check2)) {
                  flag2 = true;
              }
          }
          return flag1 && flag2;
      } else if (mat2.find()) {
          String x = mat2.group(1);
          String y = mat2.group(2);
          String check1 = x + " on " + y;
          String check2 = "clear " + x;
          String check3 = "handEmpty";
          boolean flag1 = false;
          boolean flag2 = false;
          boolean flag3 = false;
          for (int j = 0; j < nowState.size(); j++) {
              String a = (String) nowState.get(j);
              if (a.equals(check1)) {
                  flag1 = true;
              }
              if (a.equals(check2)) {
                  flag2 = true;
              }
              if (a.equals(check3)) {
                  flag3 = true;
              }
          }
          return flag1 && flag2 && flag3;
      } else if (mat3.find()) {
          String x = mat3.group(1);
          String check1 = "ontable " + x;
          String check2 = "clear " + x;
          String check3 = "handEmpty";
          boolean flag1 = false;
          boolean flag2 = false;
          boolean flag3 = false;
          for (int j = 0; j < nowState.size(); j++) {
              String a = (String) nowState.get(j);
              if (a.equals(check1)) {
                  flag1 = true;
              }
              if (a.equals(check2)) {
                  flag2 = true;
              }
              if (a.equals(check3)) {
                  flag3 = true;
              }
          }
          return flag1 && flag2 && flag3;
      } else if (mat4.find()) {
          String x = mat4.group(1);
          String check1 = "holding " + x;
          boolean flag1 = false;
          for (int j = 0; j < nowState.size(); j++) {
              String a = (String) nowState.get(j);
              if (a.equals(check1)) {
                  flag1 = true;
              }
          }
          return flag1;
      }

      return false;
  }
</pre>
<p>
  下記は nextStep() メソッドの実装である．ここで特筆すべき点は，checkOrder() メソッドと同様に，オペレータのパターンを4つ用意して正規表現によるマッチングを使用していることである．それぞれマッチングしたオペレータに対する処理の中では boolean 型の flag により，引数として与えられた状態に対してオペレータが実行できるか否かを管理している．
</p>
<pre class="brush: java">
  public Vector nextStep(Vector now, String plan1) {
      Vector re = new Vector();
      Pattern pat1 = Pattern.compile("Place (.+) on (.+)");
      Matcher mat1 = pat1.matcher(plan1);
      Pattern pat2 = Pattern.compile("remove (.+) from on top (.+)");
      Matcher mat2 = pat2.matcher(plan1);
      Pattern pat3 = Pattern.compile("pick up (.+) from the table");
      Matcher mat3 = pat3.matcher(plan1);
      Pattern pat4 = Pattern.compile("put (.+) down on the table");
      Matcher mat4 = pat4.matcher(plan1);
      if (mat1.find()) {
          String x = mat1.group(1);
          String y = mat1.group(2);
          String check = "clear " + y;
          String check1 = "holding " + x;
          for (int j = 0; j < now.size(); j++) {
              String a = (String) now.get(j);
              boolean flag = true;
              if (a.equals(check)) {
                  flag = false;
              }
              if (a.equals(check1)) {
                  flag = false;
              }
              if (flag) {
                  re.addElement(a);
              }
          }
          re.addElement(x + " on " + y);
          re.addElement("clear " + x);
          re.addElement("handEmpty");
      } else if (mat2.find()) {
          String x = mat2.group(1);
          String y = mat2.group(2);
          String check = x + " on " + y;
          String check1 = "clear " + x;
          String check2 = "handEmpty";
          for (int j = 0; j < now.size(); j++) {
              String a = (String) now.get(j);
              boolean flag = true;
              if (a.equals(check)) {
                  flag = false;
              }
              if (a.equals(check1)) {
                  flag = false;
              }
              if (a.equals(check2)) {
                  flag = false;
              }
              if (flag) {
                  re.addElement(a);
              }
          }
          re.addElement("clear " + y);
          re.addElement("holding " + x);
      } else if (mat3.find()) {
          String x = mat3.group(1);
          String check = "ontable " + x;
          String check1 = "clear " + x;
          String check2 = "handEmpty";
          for (int j = 0; j < now.size(); j++) {
              String a = (String) now.get(j);
              boolean flag = true;
              if (a.equals(check)) {
                  flag = false;
              }
              if (a.equals(check1)) {
                  flag = false;
              }
              if (a.equals(check2)) {
                  flag = false;
              }
              if (flag) {
                  re.addElement(a);
              }
          }
          re.addElement("holding " + x);
      } else if (mat4.find()) {
          String x = mat4.group(1);
          String check = "holding " + x;
          for (int j = 0; j < now.size(); j++) {
              String a = (String) now.get(j);
              boolean flag = true;
              if (a.equals(check)) {
                  flag = false;
              }
              if (flag) {
                  re.addElement(a);
              }
          }
          re.addElement("ontable " + x);
          re.addElement("clear " + x);
          re.addElement("handEmpty");
      }

      return re;
  }
</pre>
<p>
  下記は changeInitialState() メソッドの実装である．ここで特筆すべき点は，引数として与えられた命令文であるクラス String 型の order の構造に着目して，order がどの単語で始まるかについてif文による場合分けを行っていることである．場合分けを行った後は，引数として与えられた初期状態である initialState を変更している．
</p>
<pre class="brush: java">
  public Vector changeInitialState(Vector initialState, String order) {
      if (order.startsWith("add")) {
          order = order.substring(4); // orderから"add"を削除
//            System.out.println(order);
          if (!initialState.contains(order)) {
              initialState.addElement(order);
          }
      } else if (order.startsWith("append")) {
          order = order.substring(7); // orderから"append"を削除
//            System.out.println(order);
          if (!initialState.contains(order)) {
              initialState.addElement(order);
          }
      } else if (order.startsWith("delete")) {
          order = order.substring(7); // orderから"delete"を削除
//            System.out.println(order);
          if (initialState.contains(order)) {
              initialState.removeElement(order);
          }
      } else if (order.startsWith("remove")) {
          order = order.substring(7); // orderから"remove"を削除
//            System.out.println(order);
          if (initialState.contains(order)) {
              initialState.removeElement(order);
          }
      }
//        System.out.println(initialState);
      return initialState;
  }
</pre>
<p>
  下記は changeGoalList() メソッドの実装である．ここで特筆すべき点は，changeInitialState() メソッドと同様に，引数として与えられた命令文であるクラス String 型の order の構造に着目して，order がどの単語で始まるかについてif文による場合分けを行っていることである．場合分けを行った後は，引数として与えられた目標状態である goalList を変更している．
</p>
<pre class="brush: java">
  public Vector changeGoalList(Vector goalList, String order) {
      if (order.startsWith("add")) {
          order = order.substring(4); // orderから"add"を削除
//            System.out.println(order);
          if (!goalList.contains(order)) {
              goalList.addElement(order);
          }
      } else if (order.startsWith("append")) {
          order = order.substring(7); // orderから"append"を削除
//            System.out.println(order);
          if (!goalList.contains(order)) {
              goalList.addElement(order);
          }
      } else if (order.startsWith("delete")) {
          order = order.substring(7); // orderから"delete"を削除
//            System.out.println(order);
          if (goalList.contains(order)) {
              goalList.removeElement(order);
          }
      } else if (order.startsWith("remove")) {
          order = order.substring(7); // orderから"remove"を削除
//            System.out.println(order);
          if (goalList.contains(order)) {
              goalList.removeElement(order);
          }
      }
//        System.out.println(goalList);
      return goalList;
  }
</pre>
<p>
  planning() メソッドについて特筆すべき点は，目標を副目標に分解してプランニングを再帰的に行う後向き推論を行っていることである．引数として与えられた複数の目標集合であるクラス Vector 型の theGoalList に含まれる各プランニングを planningAGoal() メソッドを用いて行う．theGoalList に含まれる目標が一つだけであれば，その目標を planningAGoal() メソッドを用いてプランニングする．theGoalList に含まれる目標が複数あれば，一つ目の目標を planningAGoal() メソッドを用いてプランニングし，成功すればそのプランニングで生じた変数束縛情報 theBinding を使ってその他の目標のプランニングを実行する．また，プランニングが失敗したときに変数束縛情報を復元するために，プランニングの実行前に別の変数に保存している．
</p>
<p>
  planningAGoal() メソッドについて特筆すべき点は，引数として与えられた目標であるクラス String 型の theGoal が，現在の状態であるクラス Vector 型の theCurrentState で既に満たされているかどうかを調べていることである．満たしていたら，戻り値として 0 を返して終了する．満たされていない場合は，オペレータの実行を試みる．オペレータの競合解消をランダムにオペレータを選んでオペレータを並べ替える操作により行う．オペレータの順番をランダムに並べ替えることによって，同じオペレータが繰り返し選択されることを防いでいる．ランダムに生成した整数をオペレータの数で割ったあまりを選択すべきオペレータを指定する番号とすることにより，生成した整数がオペレータの数を上回ることを避けている．プランニングにおける各推論ステップでは，一つずつのオペレータのADDリストと目標集合を比較する．オペレータのADDリストにオペレータと一致するものがあれば，そのオペレータのIF部を新たに副目標としてプランニングを行う．そしてこのオペレータをプランとして加える．副目標に関してプランが確定したら，そのプランを実行し，どの事実が消去されるかを獲得する．
</p>
<p>
  rename() メソッドについて特筆すべき点は，引数として与えられたオペレータであるクラス Operator 型の theOperator に含まれる変数をリネーミングし，リネーミングしたオペレータを戻り値として返していることである．変数をリネーミングするために，ユニークな整数 uniqueNum を生成し，Operator クラスの getRenamedOperator() メソッドに渡している．
</p>
<p>
  下記は initGoalList() メソッドの実装である．ここで特筆すべき点は，読み込むファイル名をクラス String 型の fileName として指定し，fileName として指定したファイルから1行ずつ読み込んでいることである．読み込みに失敗した時の例外処理のためのtry-catch構文を使用している．
</p>
<pre class="brush: java">
  private Vector initGoalList() {
      Vector goalList = new Vector();
//        goalList.addElement("B on C");
//        goalList.addElement("A on B");

      String fileName = "GoalList.data";
      try { // ファイル読み込みに失敗した時の例外処理のためのtry-catch構文

          // 文字コードを指定してBufferedReaderオブジェクトを作る
          BufferedReader in = new BufferedReader(new InputStreamReader(new FileInputStream(fileName), "UTF-8"));

          // 変数lineに1行ずつ読み込むfor文
          for (String line = in.readLine(); line != null; line = in.readLine()) {
              goalList.addElement(line);
          }

      } catch (IOException e) {
          e.printStackTrace(); // 例外が発生した所までのスタックトレースを表示
      }
      return goalList;
  }
</pre>
<p>
  下記は initInitialState() メソッドの実装である．ここで特筆すべき点は，initGoalList() メソッドと同様に，読み込むファイル名をクラス String 型の fileName として指定し，fileName として指定したファイルから1行ずつ読み込んでいることである．読み込みに失敗した時の例外処理のためのtry-catch構文を使用している．
</p>
<pre class="brush: java">
  private Vector initInitialState() {
      Vector initialState = new Vector();
//        initialState.addElement("clear A");
//        initialState.addElement("clear B");
//        initialState.addElement("clear C");

//        initialState.addElement("ontable A");
//        initialState.addElement("ontable B");
//        initialState.addElement("ontable C");
//        initialState.addElement("handEmpty");

      String fileName = "InitialState.data";
      try { // ファイル読み込みに失敗した時の例外処理のためのtry-catch構文

          // 文字コードを指定してBufferedReaderオブジェクトを作る
          BufferedReader in = new BufferedReader(new InputStreamReader(new FileInputStream(fileName), "UTF-8"));

          // 変数lineに1行ずつ読み込むfor文
          for (String line = in.readLine(); line != null; line = in.readLine()) {
              initialState.addElement(line);
          }

      } catch (IOException e) {
          e.printStackTrace(); // 例外が発生した所までのスタックトレースを表示
      }
      return initialState;
  }
</pre>
<p>
  initOperators() メソッドについて特筆すべき点は，Operater クラスのインスタンスを生成し，Vector 型の変数 operators に保存していることである．オペレータの名前を String クラスのインスタンス，IFリスト，ADDリスト，DELETEリストを各々 Vector クラスのインスタンスとして生成している．
</p>

<h4>Operatorクラス</h4>
<p>
  続いて，先に挙げた Operator クラスが持つ コンストラクタ，getAddList(), getDeleteList(), getIfList(), toString(), applyState(), getRenamedOperator(), getVars(), makeRenamedVarsTable(), renameVars(), instantiate(), instantiateString(), var() メソッドの説明を行う．
</p>
<p>
  コンストラクタ について特筆すべき点は，オペレータの名前であるクラス String 型の name, IFリストであるクラス Vector 型の ifList, ADDリストであるクラス Vector 型の addList, DELETEリストであるクラス Vector 型の deleteList をインスタンス化していることである．
</p>
<p>
  getAddList(), getDeleteList(), getIfList() メソッドについて特筆すべき点は，これらのメソッドにより Operator クラスのメンバ変数を得ることができることである．
</p>
<p>
  toString() メソッドについて特筆すべき点は，Operator クラスのメンバ変数を一度に得ることができることである．
</p>
<p>
  applyState() メソッドについて特筆すべき点は，引数として与えられた状態であるクラス Vector 型の theState に対して addElement() メソッドを使用して，Operator クラスのメンバ変数である addList の要素をforループにより1つずつ加えて，removeElement() メソッドsを使用して，Operator クラスのメンバ変数である deleteList の要素をforループにより1つずつ削除していることである．
</p>
<p>
  getRenamedOperator() メソッドについて特筆すべき点は，Operator クラスのインスタンスのIFリスト，ADDリスト， DELETEリストに含まれる変数を getVars() メソッドを用いてクラス Vector 型の vars に格納してから，makeRenamedVarsTable() メソッドを用いて vars に含まれる各変数に対応した新たな唯一の名前を生成し，元の名前と新たな名前が対応するようにクラス Hashtable 型の変数 renamedVarsTable に格納したものを用いて，新たなIFリスト，ADDリスト，DELETEリスト，名前を作り，それを新たなオペレータとしていることである．
</p>
<p>
  getVars() メソッドについて特筆すべき点は，引数として与えられたパターンであるクラス String 型の thePattern をトークンに分解し，それぞれのトークンが変数であるかどうかを vars() メソッドを使用して判定していることである．
</p>
<p>
  makeRenamedVarsTable() メソッドについて特筆すべき点は，引数として与えられた変数の集合であるクラス Vector 型の vars に含まれる変数各々に対して，int 型の uniqueNum によってリネーミングした新たな変数を生成し，クラス Hashtable 型の result に格納していることである．
</p>
<p>
  renameVars() メソッドについて特筆すべき点は，引数として与えられたパターンであるクラス String 型の thePattern をトークンに分割し，トークンそれぞれについてそのトークンが変数であれば，その変数の名前をリネーミングした新たな変数名をクラス Hashtable 型の renamedVarsTable から取得していることである．トークンが変数でなければそのままにしている．
</p>
<p>
  instantiate() メソッドについて特筆すべき点は，Operator クラスのインスタンスの名前，IFリスト，ADDリスト，DELETEリストに現れる各変数を instantiateString() メソッドを用いて，引数として与えられたクラス Hashtable 型の theBinding を基に，各変数に対応した値に置き換えていることである．
</p>
<p>
  instantiateString() メソッドについて特筆すべき点は，引数として与えられたパターンであるクラス String 型の thePattern をトークンに分割して，各トークンが変数であればその変数の値を引数として与えられたクラス Hashtable 型の theBinding から取得していることである．変数の値が取得できない場合は，そのまま値を代入する．トークンが変数でなければ，そのまま返している．
</p>
<p>
  var() メソッドについて特筆すべき点は，引数として与えられたクラス String 型の str1 の先頭が?なら変数としていることである．String クラスの startsWith() メソッドにより判定を行っている．
</p>

<h4>Unifierクラス</h4>
<p>
  続いて，先に挙げた Unifier クラスが持つ コンストラクタ，3引数のunify(), 2引数のunify(), tokenMatching(), varMatching(), replaceBuffer(), replaceBindings(), var() メソッドの説明を行う．
</p>
<p>
  コンストラクタについて特筆すべき点は，パターンマッチングの課題で使用した際とは異なり，クラス HashMap 型の vars をインスタンス化してしていないことである．
</p>
<p>
  3引数のunify() メソッドについて特筆すべき点は，引数として得たクラス HashMap 型の theBindings を初期の変数束縛情報としてもつことができるようになっていることである．変数束縛情報について初期値をもっているために，unify() メソッドの実行が進行し失敗したら，変数束縛情報を初期値に戻す必要があるため，変数束縛情報をクラス HashMap 型の orgBindings として保存してから 2引数のunify() メソッドを実行する．もし失敗したら，変数束縛情報を元の初期値に戻す操作を実行する．
</p>
<p>
  2引数のunify() メソッドについて特筆すべき点は，引数として得たクラス String 型の string1 と，クラス String 型の string2が同じなら true を返し，異なれば各々トークンに分けてパターンマッチングを行っていることである．初期値として変数束縛情報が与えられていたら，その変数束縛情報に基づいてトークンを具体化している．
</p>
<p>
  tokenMatching() メソッドについて特筆すべき点は，引数として得たクラス String 型の token1 と，クラス String 型の token2 が等しければ true を返し，varMatching() メソッドの引数として与えた結果が成功したら true を返し，失敗したら false を返していることである．
</p>
<p>
  varMatching() メソッドについて特筆すべき点は，Unifier クラスのインスタンスの変数束縛情報が保管されている vars に引数として与えられたクラス String 型の vartoken がキーとして含まれている場合といない場合の場合分けがされていることである．vartoken がキーとして含まれていない場合は replaceBindings() メソッドを使用して，さらに vartoken がキー値として含まれている場合は replaceBindings() メソッドを使用している．
</p>
<p>
  replaceBuffer() メソッドについて特筆すべき点は，forループにより1つ目の引数として与えられたクラス String 型の変数 preString と同じ名前の変数が配列 buffer1, buffer2 中に存在するかを走査し，もし存在すればその変数を2つ目の引数として与えられたクラス String 型の変数 postString に置き換えていることである．
</p>
<p>
  replaceBindings() メソッドについて特筆すべき点は，クラス Iterator 型の変数 keys をforループのイテレータとして使用していることである．Iteratorクラスの使用により，処理速度を向上させている．forループ内では1つ目の引数として与えられたクラス String 型の変数 preString をハッシュ値に持つキーがあれば，そのキーのハッシュ値を2つ目の引数として与えられたクラス String 型の変数 postString に変更するという操作を行なっている
</p>
<p>
  var() メソッドについて特筆すべき点は，Stringクラスの startsWith() メソッドを使用して，引数として与えられたクラス String 型の変数 str1 がパターンマッチングにおける変数かどうか確かめ，変数ならtrueを，そうでないならfalseを返している点である．
</p>
<h4>GUI関連での変更</h4>
actionPerformedメソッドにボタンを追加した。<br>
<pre class="brush:java">
	String order = query.getText();
</pre>
ここで命令文を読み込んでいる。<br>
まず初期状態に関する命令の場合は
<pre class="brush:java">
					String filename = asfilename.getText();
					BufferedWriter in = new BufferedWriter(
							new OutputStreamWriter(new FileOutputStream(
									filename), "UTF-8"));
					String[] s1 = as.getText().split("\n");
					aslist.clear();
					for (String str : s1) {
						aslist.add(str);
					}
					String orderInitialState = order.substring(0,
							order.indexOf("in initialState") - 1);
					// System.out.println(orderInitialState);
					aslist = Planner.changeInitialState(aslist,
							orderInitialState);

					for (String str : aslist) {
						in.write(str);
						in.newLine();
					}
					in.close();
					as.setText("");
					for (String str : aslist) {
						System.out.println(str);
						as.append(str + "\n");
					}
</pre>
ファイル名を読み込む。<br>
changeInitialStateメソッドをもちいてリストを変更しテキストエリアの書き換えを行う。<br>
目標状態に関する命令の場合も同様である。<br>
ブロック操作の場合はcheckOrderメソッドをもちいて現在の状態でそのプランが実行できるかを調べる。<br>
実行可能の場合はplandoingをもちいて状態を更新してブロックの状態を更新している。<br>
画面を更新した後は
<pre class="brush:java">
					Planner.restart(filename1, Planner.state);
					Planner.state = memory;
					// System.out.println(Planner.state);
					Img.setText("");
					for (int i = 0; i < Planner.plan.size(); i++) {
						Operator op = (Operator) Planner.plan.elementAt(i);
						Img.append((String) op.instantiate(Planner.re).name
								+ "\n");
					}
</pre>
restartメソッドをもちいて再度プランニングを実施する。<br>
初期状態をもとに戻した後、得たプランをテキストエリアに表示している。<br>
changeInitialStateメソッドでは命令文の最初の文字に応じて操作が変わる。<br>
追加する場合は命令部分をsubstringで取り除いた後
<pre class="brush:java">
			if (!initialState.contains(order)) {
				initialState.add(order);
			}
</pre>
条件にすでに含まれていなければ追加されるようになっている。<br>
削除する場合も同様に命令部分をsubstringで取り除く。<br>
その後
<pre class="brush:java">
			if (initialState.contains(order)) {
				// System.out.println(order);
				initialState.remove(initialState.indexOf(order));
			}
</pre>
初期状態に含まれていたらそれを取り除くようになっている。<br>
changeGoalListメソッドでは文章から目標状態の変更を行っている。<br>
プログラムは基本的にchengeInitialStateメソッドと同じなので説明を省略する。<br>
<h3>実行例</h3>
<!-- 実行例を示す．PNGやGIF等の絵を張っても良い．-->
<h4>途中で自然言語によるブロックの操作を行わない場合</h4>
<p>
  InitialState.dataを初期状態，GoalList.dataを目標状態としてプランニングを実行し，コンソール上でenterを押して1ステップずつオペレータを実行した結果のコンソールの出力を以下に示す．
</p>
<pre>
  *** GOALS ***[B on C, A on B]
  **B on C
  newOperator name: Place B on C
  *** GOALS ***[clear C, holding B]
  **clear C
  theCurrentState: [clear A, clear B, clear C, ontable A, ontable B, ontable C, handEmpty]
  *** GOALS ***[holding B]
  **holding B
  newOperator name: pick up B from the table
  *** GOALS ***[ontable B, clear B, handEmpty]
  **ontable B
  theCurrentState: [clear A, clear B, clear C, ontable A, ontable B, ontable C, handEmpty]
  *** GOALS ***[clear B, handEmpty]
  **clear B
  theCurrentState: [clear A, clear B, clear C, ontable A, ontable B, ontable C, handEmpty]
  *** GOALS ***[handEmpty]
  **handEmpty
  State Changed.
  newOperator name inside: pick up B from the table
  State Changed.
  newOperator name inside: Place B on C
  theCurrentState: [clear A, ontable A, ontable C, B on C, clear B, handEmpty]
  *** GOALS ***[A on B]
  **A on B
  newOperator name: Place A on B
  *** GOALS ***[clear B, holding A]
  **clear B
  theCurrentState: [clear A, ontable A, ontable C, B on C, clear B, handEmpty]
  *** GOALS ***[holding A]
  **holding A
  newOperator name: pick up A from the table
  *** GOALS ***[ontable A, clear A, handEmpty]
  **ontable A
  theCurrentState: [clear A, ontable A, ontable C, B on C, clear B, handEmpty]
  *** GOALS ***[clear A, handEmpty]
  **clear A
  theCurrentState: [clear A, ontable A, ontable C, B on C, clear B, handEmpty]
  *** GOALS ***[handEmpty]
  **handEmpty
  State Changed.
  newOperator name inside: pick up A from the table
  State Changed.
  newOperator name inside: Place A on B
  ***** This is a plan! *****
  pick up B from the table
  Place B on C
  pick up A from the table
  Place A on B
  [ontable C, B on C, A on B, clear A, handEmpty]
  [A on B]
  {?x5=A, ?x3=A, ?x2=B, ?y3=B, ?x0=B, ?y0=C}
  [clear A, clear B, clear C, ontable A, ontable B, ontable C, handEmpty]
  pick up B from the table[clear A, clear C, ontable A, ontable C, holding B]


  Place B on C[clear A, ontable A, ontable C, B on C, clear B, handEmpty]

  pick up A from the table[ontable C, B on C, clear B, holding A]

  Place A on B[ontable C, B on C, A on B, clear A, handEmpty]
</pre>
<p>
  正しい出力が得られた．
</p>

<h4>途中で自然言語によるブロックの操作を行う場合</h4>
<p>
  InitialState.dataを初期状態，GoalList.dataを目標状態としてプランニングを実行し，途中でコンソールに自然言語によるブロックの操作を行う命令を入力した結果のコンソールの出力を以下に示す．
</p>
<pre>
  *** GOALS ***[B on C, A on B]
  **B on C
  newOperator name: Place B on C
  *** GOALS ***[clear C, holding B]
  **clear C
  theCurrentState: [clear A, clear B, clear C, ontable A, ontable B, ontable C, handEmpty]
  *** GOALS ***[holding B]
  **holding B
  newOperator name: remove B from on top ?y4
  *** GOALS ***[B on ?y4, clear B, handEmpty]
  **B on ?y4
  newOperator name: Place B on ?y8
  *** GOALS ***[clear ?y8, holding B]
  **clear ?y8
  theCurrentState: [clear A, clear B, clear C, ontable A, ontable B, ontable C, handEmpty]
  *** GOALS ***[holding B]
  **holding B
  newOperator name: remove B from on top ?y9
  *** GOALS ***[B on ?y9, clear B, handEmpty]
  **B on ?y9
  newOperator name: Place B on ?y11
  *** GOALS ***[clear ?y11, holding B]
  **clear ?y11
  theCurrentState: [clear A, clear B, clear C, ontable A, ontable B, ontable C, handEmpty]
  *** GOALS ***[holding B]
  **holding B
  newOperator name: pick up B from the table
  *** GOALS ***[ontable B, clear B, handEmpty]
  **ontable B
  theCurrentState: [clear A, clear B, clear C, ontable A, ontable B, ontable C, handEmpty]
  *** GOALS ***[clear B, handEmpty]
  **clear B
  theCurrentState: [clear A, clear B, clear C, ontable A, ontable B, ontable C, handEmpty]
  *** GOALS ***[handEmpty]
  **handEmpty
  State Changed.
  newOperator name inside: pick up B from the table
  State Changed.
  newOperator name inside: Place B on ?y11
  theCurrentState: [clear A, clear C, ontable A, ontable C, B on ?y11, clear B, handEmpty]
  *** GOALS ***[clear B, handEmpty]
  **clear B
  theCurrentState: [clear A, clear C, ontable A, ontable C, B on ?y11, clear B, handEmpty]
  *** GOALS ***[handEmpty]
  **handEmpty
  State Changed.
  newOperator name inside: remove B from on top ?y9
  State Changed.
  newOperator name inside: Place B on ?y8
  theCurrentState: [clear A, clear C, ontable A, ontable C, B on ?y11, clear ?y9, B on ?y8, clear B, handEmpty]
  *** GOALS ***[clear B, handEmpty]
  **clear B
  theCurrentState: [clear A, clear C, ontable A, ontable C, B on ?y11, clear ?y9, B on ?y8, clear B, handEmpty]
  *** GOALS ***[handEmpty]
  **handEmpty
  State Changed.
  newOperator name inside: remove B from on top ?y4
  State Changed.
  newOperator name inside: Place B on C
  theCurrentState: [clear A, ontable A, ontable C, B on ?y11, clear ?y9, B on ?y8, clear ?y4, B on C, clear B, handEmpty]
  *** GOALS ***[A on B]
  **A on B
  newOperator name: Place A on B
  *** GOALS ***[clear B, holding A]
  **clear B
  theCurrentState: [clear A, ontable A, ontable C, B on ?y11, clear ?y9, B on ?y8, clear ?y4, B on C, clear B, handEmpty]
  *** GOALS ***[holding A]
  **holding A
  newOperator name: pick up A from the table
  *** GOALS ***[ontable A, clear A, handEmpty]
  **ontable A
  theCurrentState: [clear A, ontable A, ontable C, B on ?y11, clear ?y9, B on ?y8, clear ?y4, B on C, clear B, handEmpty]
  *** GOALS ***[clear A, handEmpty]
  **clear A
  theCurrentState: [clear A, ontable A, ontable C, B on ?y11, clear ?y9, B on ?y8, clear ?y4, B on C, clear B, handEmpty]
  *** GOALS ***[handEmpty]
  **handEmpty
  State Changed.
  newOperator name inside: pick up A from the table
  State Changed.
  newOperator name inside: Place A on B
  ***** This is a plan! *****
  pick up B from the table
  Place B on A
  remove B from on top A
  Place B on A
  remove B from on top A
  Place B on C
  pick up A from the table
  Place A on B
  [ontable C, B on ?y11, clear ?y9, B on ?y8, clear ?y4, B on C, A on B, clear A, handEmpty]
  [A on B]
  {?y9=A, ?y8=A, ?x16=A, ?x15=A, ?y4=A, ?y3=C, ?x12=B, ?x11=B, ?x9=B, ?y15=B, ?x8=B, ?y11=A, ?x4=B, ?x3=B}
  [clear A, clear B, clear C, ontable A, ontable B, ontable C, handEmpty]
  pick up B from the table[clear A, clear C, ontable A, ontable C, holding B]


  Place B on A[clear A, clear C, ontable A, ontable C, B on ?y11, clear B, handEmpty]

  remove B from on top A[clear A, clear C, ontable A, ontable C, B on ?y11, clear ?y9, holding B]
  Place B on C       <- 自然言語によるブロックの操作を行う命令
  new operator: Place B on C
  Re Planning        <- 再度プランニングを実行
  *** GOALS ***[B on C, A on B]
  **B on C
  theCurrentState: [clear A, ontable A, ontable C, B on ?y11, clear ?y9, B on C, clear B, handEmpty]
  *** GOALS ***[A on B]
  **A on B
  newOperator name: Place A on B
  *** GOALS ***[clear B, holding A]
  **clear B
  theCurrentState: [clear A, ontable A, ontable C, B on ?y11, clear ?y9, B on C, clear B, handEmpty]
  *** GOALS ***[holding A]
  **holding A
  newOperator name: pick up A from the table
  *** GOALS ***[ontable A, clear A, handEmpty]
  **ontable A
  theCurrentState: [clear A, ontable A, ontable C, B on ?y11, clear ?y9, B on C, clear B, handEmpty]
  *** GOALS ***[clear A, handEmpty]
  **clear A
  theCurrentState: [clear A, ontable A, ontable C, B on ?y11, clear ?y9, B on C, clear B, handEmpty]
  *** GOALS ***[handEmpty]
  **handEmpty
  State Changed.
  newOperator name inside: pick up A from the table
  State Changed.
  newOperator name inside: Place A on B
  ***** This is a plan! *****
  pick up A from the table
  Place A on B
  [ontable C, B on ?y11, clear ?y9, B on C, A on B, clear A, handEmpty]
  [A on B]
  {?y11=C, ?y19=B, ?x20=A, ?y9=B, ?x19=A}
  [clear A, ontable A, ontable C, B on ?y11, clear ?y9, B on C, clear B, handEmpty]
  pick up A from the table[ontable C, B on ?y11, clear ?y9, B on C, clear B, holding A]

  Place A on B[ontable C, B on ?y11, clear ?y9, B on C, A on B, clear A, handEmpty]
</pre>
<p>
  正しい出力が得られた．
</p>
<h4>GUI上での実行例</h4>
<img src = "taka8.png"width = "600" height="400">
<img src = "taka9.png"width = "600" height="400"><br>
ちゃんと追加されている。<br>
<img src = "taka10.png"width = "600" height="400">
<img src = "taka11.png"width = "600" height="400"><br>
ちゃんと削除されている。<br>
<img src = "taka12.png"width = "600" height="400">
<img src = "taka13.png"width = "600" height="400"><br>
ちゃんと追加されている。<br>
<img src = "taka14.png"width = "600" height="400">
<img src = "taka15.png"width = "600" height="400"><br>
ちゃんと削除されている。<br>
<img src = "taka16.png"width = "600" height="400">
<img src = "taka17.png"width = "600" height="400"><br>
この状態で命令を実行すると<br>
<img src = "taka19.png"width = "600" height="400">
<img src = "taka18.png"width = "600" height="400"><br>
指示通りブロックが動かされておりプランも更新されている。<br>
<!-- 画像ファイルを貼る場合は <img> タグを使う -->
<h2>発展課題7-7</h2>
<!-- 以下，上記と同様 -->
教科書3.3節のプランニング手法を応用できそうなブロック操作以外のタスクをグループで話し合い，新たなプランニング課題を自由に設定せよ．
さらに，もし可能であれば，その自己設定課題を解くプランニングシステムを実装せよ． 
<h3>独自仕様の説明</h3>
<!--
 もし自分で独自に決めた仕様があれば，その説明を書く．
-->
<p>ブロック操作以外のタスクとして、食事をする哲学者問題をプランニングによって解く。</p>食事をする哲学者問題とは、並列処理に関する問題例として昔から取り上げられている問題である。</br>

<p>5人の哲学者が食事したり、考え事をしたりしている。かれらの前には、真ん中にスパゲッティの入った大きなボールが置かれた丸い食卓がある。その食卓には5枚の皿が置かれ、皿と皿の間にフォークが1本ずつ置かれている。

スパゲッティをボールから取って自分の皿によそうには2本のフォークを必要とし、哲学者は一度に1本のフォークしかテーブルから取ることができない（左右の手で同時に両側にある2本のフォークを取ることはできない、という意味。まずどちらかの側のフォークを取ってから、逆の側のフォークを取る）。哲学者同士は決して会話をしない。このため、5人が左のフォークを手にとって右のフォークが食卓に置かれるのを待つという危険なデッドロック状態が発生する可能性がある。</p>
本来この問題は解答例を前向きに推論して解を得ることができるか議論するような問題であるが、今回は後ろ向きに推論し、確実に解を得る(ある人物を食事状態にする)ことを目標とした。</br>
また、人数は5人に固定する。</br>
</br>
以下のような配置を考える。</br>
<img src="./Dining philosopher.png" width="60%" height="60%">
</br>
今回このプランニングを実装する上で必要と考える状態、ルールを以下に示す。</br>
</br>
<b>状態</b></br>
・philosopher○ has fork △ on the left hand</br>
・philosopher○ has fork △ on the right hand</br>
・philosopher○ has nothing on the left hand</br>
これは哲学者の右手、左手の状態を表す状態である。</br>
○には哲学者の名前、△にはフォークの番号が入る。</br>
哲学者の手があいている状態はnothingであらわす。</br>
以上のような状態を常に人それぞれ10つ(5×2)用意し、誰がどのフォークを持っているかを管理する。</br></br>


・philosopher○ is eating</br>
これは哲学者○が食事をしている状態である。</br></br>
・ontable fork △</br>
これはフォーク△がテーブルにあることを示す状態である。</br></br>

<b>初期状態</b></br>
初期状態は、全員の哲学者がフォークを持っていなく、全てのフォークがテーブルに置かれた状態</br>
</br>
philosopher A has nothing on the left hand</br>
philosopher A has nothing on the right hand</br>
philosopher B has nothing on the left hand</br>
philosopher B has nothing on the right hand</br>
philosopher C has nothing on the left hand</br>
philosopher C has nothing on the right hand</br>
philosopher D has nothing on the left hand</br>
philosopher D has nothing on the right hand</br>
philosopher E has nothing on the left hand</br>
philosopher E has nothing on the right hand</br>
ontable fork 1</br>
ontable fork 2</br>
ontable fork 3</br>
ontable fork 4</br>
ontable fork 5</br>
</br>
としているが、矛盾を起こさない限り変更は可能である。</br></br>

<b>目標状態</b></br>
目標状態は、基本的に哲学者○が食事をしている状態を表す"philosopher○ is eating"とする。</br>
ここも変更は可能である(フォークを片手に持っている状態など)</br></br>

<b>ルール</b></br>
Rule 1</br>
NAME Eating philosopher A</br> 
IF philosopher A has fork 1 on the left hand</br>
   philosopher A has fork 5 on the right hand</br>
ADD philosopher A is eating</br>
DELETE</br>
</br>
Rule 2</br>
NAME Eating philosopher B</br> 
IF philosopher B has fork 2 on the left hand</br>
   philosopher B has fork 1 on the right hand</br>
ADD philosopher B is eating</br>
DELETE -</br>
...</br>
</br>
ルール1〜5では、それぞれの哲学者がゴール(食事状態)となる条件を与えている。</br>
例えばルール1のIF部は哲学者Aが食事をするための条件を示しており、左手にフォーク1、右手にフォーク5を持つことで食事状態となる。</br>
このようなルールを5人分設定している。</br>
</br></br>
Rule 6</br>
NAME put fork ?y down on the table for philosopher ?x</br> 
IF philosopher ?x has fork ?y on the ?a hand</br>
ADD philosopher ?x has nothing on the ?a hand</br>
  ontable fork ?y</br>
DELETE philosopher ?x has fork ?y on the ?a hand</br>
</br>
ルール6では哲学者が持つフォークをテーブルに置く動作を示している。</br>
哲学者?xがフォーク?yを?a手に持っている場合、そのフォークを置くことができる。</br>
NAMEの?yにはフォーク番号が入り、?xには哲学者の名前が入る。また?aには右左が入る。</br>
</br></br>
Rule 7</br>
NAME pick up fork ?y from the table for philosopher ?x</br> 
IF ontable fork ?y</br>
  philosopher ?x has nothing on the ?a hand</br>
ADD philosopher ?x has fork ?y on the ?a hand</br>
DELETE ontable fork ?y</br>
  philosopher ?x has nothing on the ?a hand</br>
</br>
ルール7ではテーブルの上にあるフォークを哲学者が持つ操作を示している。</br>
テーブルの上にfork ?yがあり、哲学者 ?xが?a手に何も持っていない場合、?yを手に取ることができる。</br>
ルール6と同様NAMEの?yにはフォーク番号が入り、?xには哲学者の名前が入る。また?aには右左が入る。</br>
<h3>プログラムの構造</h3>
<!--  どのような設計をしたか．-->

<p>
配布されたPlannerプログラムからinitInitialState,initGoalList,initOperatorsを変更した。</br>
変更内容は上で述べたので割愛する。</br>
</p>


<h3>実装の説明</h3>
<!--
 どう実装したか，ソースコードを詳細に説明する．
 特に重要な箇所はレポートにペーストして説明する．
-->
<p>
同様に割愛する。</br>
</p>

<!--
  ソースコードをはりつける時は <pre> タグを使う
  class="brush: java" でシンタックスハイライトする
  重要な部分のみを貼り付ければ良い
-->


<h3>実行例</h3>
<p>
<!-- 実行例を示す．PNGやGIF等の絵を張っても良い．-->
初期状態を、哲学者Bがフォーク1とフォーク2を持っている状態</br>
philosopher A has nothing on the left hand</br>
philosopher A has nothing on the right hand</br>
philosopher B has fork 2 on the left hand</br>
philosopher B has fork 1 on the right hand</br>
philosopher C has nothing on the left hand</br>
philosopher C has nothing on the right hand</br>
philosopher D has nothing on the left hand</br>
philosopher D has nothing on the right hand</br>
philosopher E has nothing on the left hand</br>
philosopher E has nothing on the right hand</br>
ontable fork 3</br>
ontable fork 4</br>
ontable fork 5</br>
</p>
とし、</br>
目標状態を、AとCが食事をしている状態</br>
philosopher A is eating</br>
philosopher C is eating</br>
としたときのplan(解)を以下に示す。</br></br>
<!-- 画像ファイルを貼る場合は <img> タグを使う -->
<img src="./7-7.png"/>
</br>
<p>
解は、Bがフォーク1をテーブルに置き(2文目)、</br>
Aが置いたフォーク1とフォーク5を手に取りAを食事状態とする(3,4文目)。</br>
その後、Cがフォーク3を拾った後(6文目)、Bがフォーク2をテーブルに置き(7文目)、Cがフォーク2を取り上げている(8文目)。</br>
</p>


<h2>考察</h2>
<b>課題7-1</b></br>
<b>解決した問題点1</b></br>
配布されたプログラムをそのまま実行すると、"Place A on A"など、Aの上にAを置く動作が確認できる。</br>
この動作は、Aという物体が2つ以上存在しない限りあり得ない動作なのでこのエラーを修正する。</br>
<b>原因</b></br>
<p>
目標を副目標に分解している際、目標状態リスト内に"holding A"という状態が存在することがある。</br>
現在状態(CurrentState)内に"holding A"という状態が存在しない限り、目標"holding A"はさらに副目標に分解されることになる。</br>
"holding ?x"がADD-Listに存在するルールはオペレーター2（テーブルの上から手への移動）とオペレーター3(ブロックの上から手への移動)である。
本来オペレーター3を選択するべき場面でオペレーター2が選択されてしまった場合、次の副目標へ分解の際にプログラムはオペレーター1を選択することになる。そのときにブロックAはあるブロックの上から動かしたわけではないことから、?yに適切な値を入力することができなくなり、このエラーが生じる。</br>
現実世界で実際にブロックを操作する際にブロックを手に取る("holding ?x")ことになるのは、あるブロックの上に存在するブロックを手に取るときと、テーブルの上にあるブロックを持ち上げるときである。例えば現実世界でブロックAがテーブルの上にあり、ブロックAを動かすべき状態になったとき、オペレーター2を選択するのが正しい選択となる。しかし、プランニングのプログラムでは、後ろ向きに推論しているためADDリストに"holding ?x"があるだけでそのオペレーターを選択してしまう。</br>
</p>

<b>解決策</b></br>
<p>
この問題を解決するには、状態を"holding A"ではなく"holding A from table"等、状態"holding"を細分化し、ルールで競合が起こらないようにするなどが考えられるが、ここではもっと簡潔にこの問題を解決する。</br>
今回の課題7-1では、初期状態として全てのブロックはテーブルと接している形が与えられている。</br>
ここで、この初期状態からブロックを最適な方法で操作することができるならば、あるブロックの上に存在するブロックを操作するオペレーター3は最適解に含まれることはないという事実を利用する。</br>
よって、オペレーター3の優先度を最小にする。</br>
またこれにより最適解を得られなくなる要因の競合は発生しなくなるので、最適解を得ることができる。</br>
</p>

<b>問題点</b></br>
<p>
今回の課題7-1では対象外であるが、初期状態も変更の対象となる場合この解決策では破綻する。</br>
理由は解決策の欄でも述べたが、ブロックの上に存在するブロックを動かさないといけない初期状態が与えられたときにオペレーター3が選択されることがなくなり、無限ループに陥ってしまうからである。</br>
</p></br>
</br>

<b>解決した問題点2</b></br>
目標状態を"B on C"、"A on B"ではなく"A on B"、"B on C"のように物体の位置が上のものから入力してしまうと正しく解を得ることができない。</br>

<b>原因</b></br>
このプログラムは、目標を副目標に分解し、全ての副目標がCurrentListに存在する場合、目標の分解をやめ、動作を確定させている。</br>
ゴールリストから分解対象を取り出すのは上から順番であるため、"A on B"を取り出し、AをBの上にのせる手順を確定させてしまうためにこのエラーが起こる。</br>
<b>解決策</b></br>
目標状態を格納するときに位置が下からとなるようにソートし、GoalListに格納する。</br></br></br>
<h3>課題7-3</h3>
plandoingを実行する際のプランはプランニングによって導き出されたプランであるので確実にその状態で実行可能であるプランであると考えた。<br>
したがってif部が成立するかどうかのチェックは不必要と考え、addとdeleteのみの処理を記述してある。<br>
Place x on yのときに
<pre class="brush:java">
			 for(int i =0; i < namelist.size();i++){
				 ArrayList&ltString &gt memo = namelist.get(i);
				 if(memo.contains(y)){
					 memo.add(x);
				 }
				 namelist.remove(i);
				 namelist.add(i,memo);
			 }
</pre>
実行できるプランなのでxは手に持っている状態なのでnamelistから削除する必要はなくyはnamelistの一番上にあることは明確である。<br>
したがってyが含まれているリストにaddをするだけでブロックが上に置かれたことを表現することができるようになっている。<br>
そのように作成したリストをremoveで取り除いた後、同じ場所にaddしている。<br>
このようにすることでブロックの位置が変化することなくその場でやりとりすることが可能になっている。<br>
remove x from on top yのときブロック操作にいおいて
<pre class="brush:java">
					 for(int j =0; j < memo.size();j++){
						String s = memo.get(j);
						if(s.equals(x)){
							memo.remove(j);
						}
					 }
</pre>
としたが実行できるプランであるはずなのでxはyが含まれるブロックの一番上にあるはずである。<br>
したがって順番にたどっていき見つかったら取り除くのではなく最後尾の要素を削除するだけでよいはずなので改善すべきである。<br>
pick up x from the tableのときブロック操作において
<pre class="brush:java">
			 for(int i =0; i < namelist.size();i++){
				 ArrayList&ltString &gt memo = namelist.get(i);
				 if(memo.contains(x)){
					 memo.remove(0);
				 }
				 namelist.remove(i);
				 namelist.add(i,memo);
			 }
</pre>
仮定よりブロックxはtableの上に置いてあるはずであり、そこに積み上げられているブロックの数は1つだけである。<br>
したがってremoveで先頭の要素を取り除いている。<br>
要素数が0になったとしても削除せずにnamelistに残しておくことで他のブロックの位置が変わってしまうことを防いでいる。<br
put x down on the tableのときブロック操作において<br>
<pre class="brush:java">
			for (int i = 0; i < namelist.size(); i++) {
				ArrayList&ltString&gt memo = namelist.get(i);
				if (memo.size() == 0) {
					memo.add(x);
					namelist.remove(i);
					namelist.add(i, memo);
　　　　　　　　　　　　　　　　　　　　break;
				}
			}
</pre>
tableにおくためにはリストが空のところに追加すればよい。<br>
追加は一度だけでいいのでbreakで複数箇所におかないように対応している。<br>
getblockメソッドでは
<pre class="brush:java">
			if (mat1.find()) {
				String name1 = mat1.group(1);
				if (!name.contains(name1)) {
					name.add(name1);
					ArrayList&ltString&gt n = new ArrayList&ltString&gt();
					n.add(name1);
					namelist.add(n);

				}
			} else if (mat2.find()) {
				String name1 = mat2.group(1);
				hold = name1;
				if (!name.contains(name1)) {
					name.add(name1);
				}
			}
		}
</pre>
ontableのものはまだブロックを記憶していないもののはずなので新たにArrayListを作成してnamelistに保存している。<br>
このようにすることでベースとなるリストが作成可能になっている。<br>
holdingは1つしかできないはずなのでString型の変数にそのまま保存するだけで十分である。<br>
その下のwhile文ではx on yしかチェックをしていない。<br>
ontableとholdingをチェックし終わっているので残るブロックは必ず何かのブロックの上にあるはずである。<br>
そのためチェックするのはx on yだけでいい。<br>
<pre class="brush:java">
		for (int i = namelist.size(); i < name.size(); i++) {
			ArrayList&ltString&gt a = new ArrayList&ltString&gt();
			namelist.add(a);
		}
</pre>
namelistのサイズは最大でブロックがすべて横に並んでいる状態が考えられるのでブロックが積まれていない部分に空のリストを追加している。<br>
このようにすることでnamelistのサイズを変える必要がなくなっている。<br>
図を描画する際は同じフレーム内で表現したかったがやり方がわからなかったので別でフレームを表示するという手法をとった。<br>
オペレータは固定にしてあるのでそこも改善する必要がある。<br>
パターンマッチかなにかをもちいて削除する状態や追加する状態を取得するようにした方がよりよくなるはずである。<br>
<b>課題7-5</b><br>
<h3>自然言語の命令文を実行するタイミング</h3>
<p>
今回，ユーザが自然言語の命令文によってブロックを操作をしたり，初期状態／目標状態を変更したりできるようにするという課題であったが，ブロックの操作はプランニングを1ステップずつ進めていくときに実行し，初期状態／目標状態の変更はプランニングの実行前に行うのが自然と感じたため，そのように実装した．課題の出題としてはどのタイミングで行うかについての指定がなかったため，きちんと自分でどのタイミングで行うべきかについて考えて課題に取り組んだ．この手法は素晴らしいと言える．実装法としては，初期状態と目標状態の初期化が終わったら，プログラム中の自然言語の命令文により初期状態／目標状態の変更をして，プランニングを実行するようになっている．プランニングを実行すると初期状態が実行前から変更されてしまうため，プランニングの実行前に別のオブジェクトに保存してからプランニングを実行し，プランニング実行後に初期状態を復元して，プランニングにより得られた実行するオペレータの集合からオペレータを1つずつ読み出すことで，コンソール上で1ステップずつプランニングを実行している．コンソール上で1ステップずつプランニングを実行しつつ，標準入力により自然言語のブロック操作を実行する命令文を得て，その命令文が実行可能であればその時点の状態に対し入力されたブロック操作の命令を実行している．</p><h3>GUIへの移植を考えた設計</h3><p>  また，前回の課題6でグループ課題である以上はコードを共有することになるため，プログラムの設計を話し合った上で課題に取り組んだらスムーズに課題に取り組めたことを踏まえて，今回もプログラムの設計を話し合いながら課題を進めていった．特に課題7-3のGUIの実装を担当している27115120丹羽君と，直接話したりSlackを使用したりして，どの操作をメソッドとして用意するかやメソッドの引数について話し合いながら課題に取り組んだ．そのおかげか，自分の担当している箇所を課題7-3のGUIのソースコードに移植することがかなり楽にできたようであった．前回の課題で学んだ課題に対する良い取り組み方を忘れずに，今回の課題においても行えたことは非常に良い．失敗から学ぶのも大事だが，成功を忘れないのも大事である．</p>

<h3>Slackの活用</h3><p>  さらに，今回の課題7ではグループの進捗管理や成果物共有のツールとしてSlackを使用した．GitHubより敷居が低く，直感的な操作が行える上に，話し合いができるというのが決めてであった．前回の課題6で使用したGitHubももちろん使用したが，GitHubはプログラムがほぼ完成してから他の人のソースコードに移植するときに使用し，Slackは課題に取り組む上の話し合いやちょっとしたメソッドなど短いコードの共有に使用するという使い分けをした．Slackを介して話し合うことで勝手に話し合いのログが取れたりするので，話し合いの内容を忘れてしまってもログを見て思い出すことができたりと，かなり快適なツールであった．Slackについて，他の進捗管理や成果物共有のツールと比較しつつ，ベストな使い方ができたと言える．今後のプレゼン作成の際にも使用していきたい．</p><h3>課題量の見積もり</h3><p>  今回はできなかったが，課題量の見積もりをもっと正確にするべきである．前回の課題6と同様に，今回の課題7も先に分担を決めてから各自課題に取り組んだが，この課題はすぐ解けそうと話し合っていた課題で意外と苦戦したり，逆にこの課題は難しいと話し合っていた課題がすぐ終わってしまったりと，課題の分量や難易度の見積もりが上手くいかなかった．結局グループのメンバー全員が締め切りまでに終えれたから良いものの，分担ミスで締め切りに間に合わないなんてことは起きてはならない．課題ならまだしも，働くようになって仕事を分担する際に，仕事の量を上手く測ることができずに人月の計算を誤ってしまったら，最悪納期に間に合わないなんてことも考えられる．今回の課題で課題量の見積もりを誤ってしまったため，今後，さらには働くようになってからはそのようなミスを起こさないように気をつけたい．具体的には課題や仕事の量をある指標を用いて定量化したりすると良いと考えられる．</p>
<h3>GUI関連</h3>
鈴木祥太君に作ってもらったchengeInitialStateやchangeGoalListメソッドではGUIへ直接うつせなかったので変更を行った。<br>
もともとがVector型だったのをArrayList型に変更した。<br>
また削除する場合にもともと削除元があるかチェックをしていなかったため、削除元がない場合はエラーが起こってしまうところをなおした。<br>
<b>課題7-7</b></br>
<p>
本プログラムでは、登場する哲学者それぞれの食事条件を与えているが、これはあまりスマートなやり方といえない。</br>初めはフォークに名前をつけることは考えていなかったが、フォークに名前をつけないと哲学者が1つ隣のフォークも手を伸ばして取ってしまい食事状態になることが考えられたので、フォークに名前をつけ、ゴール条件を哲学者それぞれ与えることによって、制御に成功した。</br>
しかしルールの数が増えてしまうことや、哲学者の人数を増やすことはできないので、この制御方式は改善の余地が残されている。</br>

</p>
<p>
また"ontable fork ○"という状態は"philosopher ○ has nothing on the △ hand"と持つ情報がかなり被っており、この状態を作成するか考えたが、</br>
"ontable fork ○"という状態を追加することで、後ろ向き推論のルールを作成する際に方針がたてやすくなったり、また実行するユーザー側も"テーブルの上にfork○がある"と端末上に表示することで、実行過程が鮮明になると思いこの状態を追加した。</br>
事実、例えば、"philosopher A has nothing on the left hand"（Aは左手に何も持っていない）,"philosopher B has nothing on the right hand"(Bは右手に何も持っていない)の2文を検査することででAとBの間に存在するフォーク1の行方はわかる(この例の場合は机に存在する)。これは全ての哲学者の右手、左手の情報(計10つ)が常にCurrentListに格納されているからである。</br>

</p>

<h2>感想</h2>
<h3>27115157</h3>
今回の担当箇所はプログラムや構造をしっかりと理解しなければならない課題であったので完成に手間取った。</br>
課題7-7では、実装までいけるか不安だったけどなんとか実装することができて良かった。</br>
<h3>27115076</h3>
<p>
  課題の内容が自然言語処理というこれまでに何度か取り組んだことのあるものだったので，課題の要件を満たすのにはそれほど時間を必要としなかった．そのおかげか，他のメンバーとの話し合いを積極的に行うことができ，グループとしてのまとまりがあったように感じる．また，プログラムの設計について，main メソッドに大まかな流れを書いて，コード量が増える操作や別の流れとなる操作は別のメソッドとして用意するという，理想的なコーディングができたと思う．今後も続けていきたい．
</p>
<h3>27115120</h3>
図形を描画するための考え方を思いつくのに時間がかかった。<br>
ブロック操作は自分の理想通りになったので満足である。<br>
GUIは前回の課題で作ったやつをほとんどそのまま流用したのでプログラムの中身を理解するのに時間がかかったが応用させるのは比較的に楽だった。<br>
課題7-5で作ってほしいと言われたメソッドは方針が早めにできたので実装するのは用意であった。<br>
他の授業で中間試験があったため、あまり多くの時間を割くことができなかった。<br>
発展課題をやったり、他のメンバーの手伝いをしたかった。<br>
<h3>27115077</h3>
<p>
前回の課題の後ろ向き推論に関する理解が完ぺきではなかったため、まずプランニングのソースを読み解くのに時間が掛かった。競合解消戦略自体はいろいろなアプローチが思いついたが完璧な戦略に至ることができなかったのは悔しい。
また、自分のプログラミング力がまだまだ不足していると痛感したため鍛えていきたい。<br>
自分はunityを少し触ったことがあるので、発展課題にも挑戦してみたかったが時間の都合でできなかった。

</p>
<hr>
<h2>参考文献</h2>
<!-- 参考文献を書く．助けてもらった人がいれば，それも書く-->

<ul>
  <li>グループ3のメンバー</li>
 <li>新谷虎松 著（2014）『Javaによる知能プログラミング入門』コロナ社</li>
<li>https://www.javadrive.jp/java2d/shape/ 最終アクセス日2017年12月15日</li>

</ul>

</body> <li>新谷虎松 著（2014）『Javaによる知能プログラミング入門』コロナ社</li>
<li>https://www.javadrive.jp/java2d/shape/ 最終アクセス日2017年12月15日</li>
</html>
